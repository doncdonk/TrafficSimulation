<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>éƒ½å¸‚äº¤é€šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ v21</title>
<style>
body { margin:0; background:#1e1e1e; color:white; font-family:sans-serif; }
#ui { padding:6px; text-align:center; font-size:13px; }
#gameWrap { display:flex; justify-content:center; align-items:flex-start; gap:10px; }
canvas { background:#2b2b2b; display:block; flex-shrink:0; }
input { width:140px; }
#sidePanel {
  width:160px; background:#222; border:1px solid #444; border-radius:6px;
  padding:10px 8px; font-size:13px; display:flex; flex-direction:column; gap:8px;
  flex-shrink:0; margin-top:0;
}
#sidePanel h3 { margin:0 0 4px; font-size:14px; color:#f0c040; text-align:center; border-bottom:1px solid #444; padding-bottom:4px; }
#sidePanel .sec { font-size:11px; color:#aaa; margin-bottom:2px; }
#sidePanel button {
  width:100%; padding:5px 4px; border:none; border-radius:4px;
  cursor:pointer; font-size:12px; font-weight:bold; transition:opacity 0.15s;
}
#sidePanel button:hover { opacity:0.85; }
#sidePanel button:disabled { opacity:0.4; cursor:not-allowed; }
.btn-green  { background:#2a7a2a; color:#fff; }
.btn-red    { background:#7a2020; color:#fff; }
.btn-blue   { background:#1a4a9a; color:#fff; }
.btn-yellow { background:#8a6a00; color:#fff; }
.btn-active { outline:2px solid #f0c040; }
#budgetVal { font-size:18px; font-weight:bold; color:#f0c040; text-align:center; }
#modeLabel { text-align:center; font-size:11px; color:#80d0ff; min-height:16px; }
.cost-tag  { color:#ff9040; font-size:10px; }
#scoreBar {
  display:flex; justify-content:center; align-items:center; gap:20px;
  padding:6px 0; background:#111; border-bottom:1px solid #333;
  font-size:15px; letter-spacing:0.5px;
}
#scoreVal { font-size:22px; font-weight:bold; color:#f0c040; }
#rankVal  { font-size:18px; font-weight:bold; }
#accVal   { color:#ff6060; }
#bonusVal { color:#60d0ff; font-size:12px; }
.rank-S { color:#ff4fff; }
.rank-A { color:#ffaa00; }
.rank-B { color:#80e060; }
.rank-C { color:#60b0ff; }
.rank-D { color:#aaaaaa; }
</style>
</head>
<body>
<div id="scoreBar">
  <span>SCORE: <span id="scoreVal">0</span></span>
  <span>RANK: <span id="rankVal" class="rank-B">B</span></span>
  <span id="bonusVal">BONUS Ã—1.0</span>
  <span>äº‹æ•…: <span id="accVal">0</span>ä»¶</span>
</div>
<div id="ui">
  æµå…¥é‡: <input type="range" id="flowSlider" min="0" max="100" value="50"><span id="flowVal">50</span>
  |
  äº¤å·®ç‚¹é’æ™‚é–“: <input type="range" id="greenSlider" min="60" max="300" value="120"><span id="greenVal">120</span>
  |
  æ™‚é–“å¸¯: <span id="timeLabel">Day</span>
  |
  æ¸‹æ»: <span id="jam">0</span>
  | ç·Šæ€¥å¯¾å¿œ(-300pt): <button id="clearAccBtn" onclick="clearAccident()">ğŸš¨ å¯¾å¿œ</button>
</div>
<div id="gameWrap">
<canvas id="game" width="1000" height="700"></canvas>
<div id="sidePanel">
  <h3>ğŸ’° äºˆç®—</h3>
  <div id="budgetVal">0</div>
  <div id="modeLabel">ãƒ¢ãƒ¼ãƒ‰: é€šå¸¸</div>
  <hr style="border-color:#444;margin:2px 0">
  <div class="sec">ğŸš¦ ä¿¡å·ç®¡ç†</div>
  <button class="btn-green"  id="btnInstall" onclick="setMode('install')">ä¿¡å·è¨­ç½®<br><span class="cost-tag">-500pt</span></button>
  <button class="btn-red"    id="btnRemove"  onclick="setMode('remove')">ä¿¡å·æ’¤å»<br><span class="cost-tag">-300pt</span></button>
  <hr style="border-color:#444;margin:2px 0">
  <div class="sec">ğŸ”€ é“è·¯æ“ä½œ</div>
  <button class="btn-blue"   id="btnReverse" onclick="setMode('reverse')">ä¸€æ–¹é€šè¡Œåè»¢<br><span class="cost-tag">-800pt</span></button>
  <hr style="border-color:#444;margin:2px 0">
  <div class="sec">ğŸš¨ ç·Šæ€¥</div>
  <button class="btn-yellow" onclick="clearAccident()">äº‹æ•…å¯¾å¿œ<br><span class="cost-tag">-300pt</span></button>
  <hr style="border-color:#444;margin:2px 0">
  <button style="background:#333;color:#ccc;font-size:11px;padding:3px" onclick="setMode(null)">âœ• ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
  <div style="font-size:10px;color:#666;margin-top:4px;line-height:1.4">
    [äº¤å·®ç‚¹ã‚¯ãƒªãƒƒã‚¯]ã§ä¿¡å·æ“ä½œ<br>[é“è·¯ã‚¯ãƒªãƒƒã‚¯]ã§åè»¢
  </div>
</div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nodes = [], edges = [], cars = [];
const rivers = []; // å·ãƒ‡ãƒ¼ã‚¿: [{type:"h"|"v", y1,y2} or {x1,x2}]
let terrainCanvas = null; // åœ°å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£(ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã€generateCityæ™‚ã«ç”Ÿæˆ)
let selectedNode = null, timeCounter = 0, flowRate = 0.5;
let budget = 0;          // äºˆç®—ï¼ˆã‚¹ã‚³ã‚¢ã¨åŒæœŸï¼‰
let operationMode = null; // 'install' | 'remove' | 'reverse' | null
let selectedEdge = null;  // ä¸€æ–¹é€šè¡Œåè»¢æ™‚ã®é¸æŠã‚¨ãƒƒã‚¸
let reverseHighlight = null; // åè»¢ãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨ã‚¨ãƒƒã‚¸

// ===== ã‚¹ã‚³ã‚¢ãƒ»äº‹æ•… =====
let score = 0;
let scoreBonus = 1.0;     // æ¸‹æ»ã‚¼ãƒ­ç¶™ç¶šã§ãƒœãƒ¼ãƒŠã‚¹å€ç‡UP
let bonusStreak = 0;      // æ¸‹æ»ã‚¼ãƒ­ç¶™ç¶šãƒ•ãƒ¬ãƒ¼ãƒ æ•°
const accidents = [];     // äº‹æ•…ãƒªã‚¹ãƒˆ [{x,y,edge,timer,maxTimer,blink,police}]
const policeCars = [];    // ãƒ‘ãƒˆã‚«ãƒ¼ãƒªã‚¹ãƒˆ [{car,accidentRef}]
let accidentCount = 0;    // ç´¯è¨ˆäº‹æ•…ä»¶æ•°
const ACCIDENT_DURATION = 1800; // äº‹æ•…ç¶™ç¶šæ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ã€ç´„30ç§’@60fpsï¼‰
const ACCIDENT_SLOWZONE = 80;   // äº‹æ•…å½±éŸ¿ç¯„å›²ï¼ˆpxï¼‰

const MIN_GAP  = 20;   // å‰è»Šã¨ã®æœ€å°è·é›¢(px)
const SLOW_GAP = 60;   // æ¸›é€Ÿé–‹å§‹è·é›¢(px)
const LANE_W   = 18;   // 1è»Šç·šã®å¹…(px)

// ===== ç”»åƒ =====
const roadImg      = new Image(); roadImg.src      = "douro.png";
const onewayImg    = new Image(); onewayImg.src    = "douro_small.png";
const parkImg      = new Image(); parkImg.src      = "park1.png";
const parkingImg   = new Image(); parkingImg.src   = "parking.png";
const riverImg     = new Image(); riverImg.src     = "river.png";
const groundImgs   = [1,2,3].map(i=>{ const m=new Image(); m.src=`ground_${i}.png`; return m; });  // ground_1=è‰åœ°, ground_2=ç ‚åœ°, ground_3=åœŸ
const sigGreenImg  = new Image(); sigGreenImg.src  = "shingou_blue.png";
const sigRedImg    = new Image(); sigRedImg.src    = "shingou_red.png";
const kousatenImg  = new Image(); kousatenImg.src  = "kousaten.png"; // äº¤å·®ç‚¹ç”»åƒ 300Ã—300px
// é€²è¡Œæ–¹å‘ã‚µã‚¤ãƒ³ç”»åƒï¼ˆäº¤å·®ç‚¹æ‰‹å‰ã®è·¯é¢ã«æç”»ï¼‰
const signImgs = {
  straight:     (() => { const m=new Image(); m.src="s_straight.png";      return m; })(),
  right:        (() => { const m=new Image(); m.src="s_right.png";         return m; })(),
  left:         (() => { const m=new Image(); m.src="s_left.png";          return m; })(),
  st_right:     (() => { const m=new Image(); m.src="s_st_right.png";      return m; })(),
  st_left:      (() => { const m=new Image(); m.src="s_st_left.png";       return m; })(),
  right_left:   (() => { const m=new Image(); m.src="s_right_left.png";    return m; })(),
  st_right_left:(() => { const m=new Image(); m.src="s_st_right_left.png"; return m; })(),
};
const carImgs   = Array.from({length:10}, (_,i)=>{ const m=new Image(); m.src=`car${i+1}.png`;   return m; });
const houseImgs   = Array.from({length:8},  (_,i)=>{ const m=new Image(); m.src=`house${i+1}.png`;   return m; });
const companyImgs = Array.from({length:4},  (_,i)=>{ const m=new Image(); m.src=`company${i+1}.png`; return m; });
const policeImg   = new Image(); policeImg.src = "car_police.png";

// ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
function linesIntersect(p1,p2,p3,p4){
  if(p1===p3||p1===p4||p2===p3||p2===p4) return false;
  const ccw=(a,b,c)=>(c.y-a.y)*(b.x-a.x)>(b.y-a.y)*(c.x-a.x);
  return ccw(p1,p3,p4)!==ccw(p2,p3,p4) && ccw(p1,p2,p3)!==ccw(p1,p2,p4);
}

// ã‚ˆã‚Šå³å¯†ãªäº¤å·®åˆ¤å®šï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨ˆç®—ã§ç«¯ç‚¹ä¸Šé€šéã‚‚æ¤œå‡ºï¼‰
// å…±æœ‰ãƒãƒ¼ãƒ‰(åŒä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)ã¯OKã€ãã‚Œä»¥å¤–ã®äº¤å·®ã¯å…¨ã¦NG
// eps: ç«¯ç‚¹ä»˜è¿‘ã‚’äº¤å·®ã¨ã¿ãªã™é–¾å€¤ï¼ˆ0.02 = ç·šåˆ†ã®2%ä»¥å†…ï¼‰
function segmentsCross(p1,p2,p3,p4, eps=0.03){
  // å…±æœ‰ç«¯ç‚¹ã¯äº¤å·®æ‰±ã„ã—ãªã„
  if(p1===p3||p1===p4||p2===p3||p2===p4) return false;
  const d1x=p2.x-p1.x, d1y=p2.y-p1.y;
  const d2x=p4.x-p3.x, d2y=p4.y-p3.y;
  const denom=d1x*d2y - d1y*d2x;
  if(Math.abs(denom)<1e-10) return false; // å¹³è¡Œ
  const t=((p3.x-p1.x)*d2y-(p3.y-p1.y)*d2x)/denom;
  const u=((p3.x-p1.x)*d1y-(p3.y-p1.y)*d1x)/denom;
  // ä¸¡æ–¹ã®ç·šåˆ†ã®å†…å´ã§äº¤å·®ã—ã¦ã„ã‚Œã°çœŸ
  return t>eps && t<1-eps && u>eps && u<1-eps;
}

// æ—¢å­˜ã‚¨ãƒƒã‚¸ç¾¤ã¨ã®äº¤å·®ãƒã‚§ãƒƒã‚¯ï¼ˆå€™è£œç·šåˆ†aâ†’bãŒæ—¢å­˜ã‚¨ãƒƒã‚¸ã¨äº¤å·®ã™ã‚‹ã‹ï¼‰
// å…±æœ‰ãƒãƒ¼ãƒ‰æ¥ç¶šã¯è¨±å®¹ã™ã‚‹
function crossesAnyEdge(a, b){
  for(const e of edges){
    if(segmentsCross(a,b,e.from,e.to)) return true;
  }
  return false;
}

// ===== Node =====
class Node {
  constructor(x,y,type="cross",external=false,img=null){
    this.x=x; this.y=y; this.type=type; this.external=external; this.img=img;
    this.phase=0; this.timer=0; this.greenDuration=120;
    // hasSignal: åˆæœŸã¯ generateCity() ã§è¨­å®šï¼ˆå†…éƒ¨äº¤å·®ç‚¹ã®40%ã®ã¿trueï¼‰
    this.hasSignal = false;
  }
  update(){
    if(this.external || this.type!=="cross") return;
    if(!this.hasSignal) return; // ä¿¡å·ãªã—ã¯ã‚¿ã‚¤ãƒãƒ¼ä¸è¦
    if(++this.timer >= this.greenDuration){ this.phase=(this.phase+1)%2; this.timer=0; }
  }
  draw(){
    if(this.type==="house"||this.type==="park"||this.type==="company"){
      if(this.img) ctx.drawImage(this.img, this.x-20, this.y-20, 40, 40);
      return;
    }
    if(this.type==="parking"){
      if(parkingImg.complete&&parkingImg.naturalWidth>0){
        ctx.drawImage(parkingImg, this.x-30, this.y-30, 60, 60);
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é’ã„é§è»Šå ´ãƒãƒ¼ã‚¯
        ctx.fillStyle="#1a6bb5";
        ctx.fillRect(this.x-30, this.y-30, 60, 60);
        ctx.fillStyle="white";
        ctx.font="bold 28px sans-serif";
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.fillText("P", this.x, this.y);
      }
      return;
    }
    ctx.fillStyle = this.external ? "#444" : "#666";
    ctx.fillRect(this.x-15, this.y-15, 30, 30);
    if(this.external) return;

    // ä¿¡å·: ã“ã®ãƒãƒ¼ãƒ‰ã‚’fromã¨ã™ã‚‹ã‚¨ãƒƒã‚¸ã®æ–¹å‘ã‚’è¦‹ã‚‹
    const outEdges = edges.filter(e=>e.from===this);
    const dirs = {up:false,down:false,left:false,right:false};
    for(const e of outEdges){
      const dx=e.to.x-this.x, dy=e.to.y-this.y;
      if(Math.abs(dy)>Math.abs(dx)){ if(dy<0) dirs.up=true; else dirs.down=true; }
      else                          { if(dx<0) dirs.left=true; else dirs.right=true; }
    }
    // æ“ä½œãƒ¢ãƒ¼ãƒ‰ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    if(operationMode==='install' && !this.hasSignal){
      ctx.save();
      ctx.strokeStyle='rgba(80,255,80,0.7)';
      ctx.lineWidth=2.5;
      ctx.strokeRect(this.x-17,this.y-17,34,34);
      ctx.restore();
    } else if(operationMode==='remove' && this.hasSignal){
      ctx.save();
      ctx.strokeStyle='rgba(255,80,80,0.7)';
      ctx.lineWidth=2.5;
      ctx.strokeRect(this.x-17,this.y-17,34,34);
      ctx.restore();
    }

    // ä¿¡å·ãªã—äº¤å·®ç‚¹: é»„è‰²ã„è­¦æˆ’ãƒãƒ¼ã‚¯
    if(!this.hasSignal){
      ctx.save();
      ctx.font='bold 13px sans-serif';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillStyle='#ffdd00';
      ctx.fillText('âš ',this.x, this.y-18);
      ctx.restore();
      return; // ä¿¡å·ã¯æç”»ã—ãªã„
    }

    const vG=this.phase===0, hG=this.phase===1;

    // ä¿¡å·ç”»åƒã®æç”»
    // ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯å¾“æ¥ã®çŸ©å½¢ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    const sigReady = sigGreenImg.complete && sigGreenImg.naturalWidth > 0
                  && sigRedImg.complete  && sigRedImg.naturalWidth  > 0;

    // ä¿¡å·1ã¤ã‚’æç”»ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
    // cx,cy: æç”»ä¸­å¿ƒåº§æ¨™, angle: å›è»¢è§’(rad), isGreen: é’ã‹èµ¤ã‹
    function drawSignal(cx, cy, angle, isGreen){
      const img = isGreen ? sigGreenImg : sigRedImg;
      const W = 28, H = 10; // æç”»ã‚µã‚¤ã‚º (ç¸®å°: 400x150 ã® 1/15ç›¸å½“)
      if(sigReady){
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.drawImage(img, -W/2, -H/2, W, H);
        ctx.restore();
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è‰²ä»˜ãçŸ©å½¢
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.fillStyle = isGreen ? "#0f0" : "#f00";
        ctx.fillRect(-W/2, -H/2, W, H);
        ctx.restore();
      }
    }

    // å„æ–¹å‘ã«ä¿¡å·ã‚’é…ç½®
    // ç”»åƒã¯æ¨ªé•·(400Ã—150px)ã§å·¦ç«¯ãŒé’ç¯å´ã€‚
    // ä¿¡å·ã¯é“è·¯ã‚ãã«ã€Œè»ŠãŒæ¥ã‚‹æ–¹å‘ã‚’å‘ã„ã¦ã€ç¸¦ã«ç«‹ã¦ã‚‹ã€‚
    //
    // right(å³èµ°è¡Œ)ã®ä¿¡å·: é“è·¯ä¸Šå´ã«ç«‹ã¡ã€å³ã‚’å‘ã â†’ ç”»åƒã‚’-90åº¦å›è»¢
    // left (å·¦èµ°è¡Œ)ã®ä¿¡å·: é“è·¯ä¸‹å´ã«ç«‹ã¡ã€å·¦ã‚’å‘ã â†’ ç”»åƒã‚’+90åº¦å›è»¢
    // down (ä¸‹èµ°è¡Œ)ã®ä¿¡å·: é“è·¯å·¦å´ã«ç«‹ã¡ã€ä¸‹ã‚’å‘ã â†’ ç”»åƒã‚’0åº¦(æ¨ªãã®ã¾ã¾)
    // up  (ä¸Šèµ°è¡Œ)ã®ä¿¡å·: é“è·¯å³å´ã«ç«‹ã¡ã€ä¸Šã‚’å‘ã â†’ ç”»åƒã‚’180åº¦å›è»¢
    const SIG_DIST = 20; // äº¤å·®ç‚¹ä¸­å¿ƒã‹ã‚‰ã®è·é›¢(px)
    if(dirs.up)    drawSignal(this.x,             this.y - SIG_DIST,  Math.PI,      vG);
    if(dirs.down)  drawSignal(this.x,             this.y + SIG_DIST,  0,            vG);
    if(dirs.left)  drawSignal(this.x - SIG_DIST,  this.y,             Math.PI/2,    hG);
    if(dirs.right) drawSignal(this.x + SIG_DIST,  this.y,            -Math.PI/2,    hG);
  }
}

// ===== Edge =====
// â˜… å…¨ã‚¨ãƒƒã‚¸ã¯ fromâ†’to ã®ä¸€æ–¹é€šè¡Œã€‚
// main: åŒæ–¹å‘2è»Šç·š(ç‰‡å´2ãƒ¬ãƒ¼ãƒ³)
// branch: åŒæ–¹å‘1è»Šç·š
// åå¯¾æ–¹å‘ã®äº¤é€šã¯åˆ¥ã‚¨ãƒƒã‚¸ã¨ã—ã¦ç‹¬ç«‹å®šç¾©ã™ã‚‹ã€‚
class Edge {
  constructor(from,to,type="branch"){
    this.from=from; this.to=to; this.type=type;
    // main: 2è»Šç·š  oneway: 1è»Šç·š(é€†å‘ãã‚¨ãƒƒã‚¸ãªã—)  branch: 1è»Šç·š
    this.lanes = (type==="main") ? 2 : 1;
    this.length = Math.hypot(to.x-from.x, to.y-from.y);
    this.laneCars = Array.from({length:this.lanes}, ()=>[]);
  }
}

// ===== Car =====
// â˜… å·¦å´é€šè¡Œã®åŸå‰‡:
//   nx = (-vy/len, vx/len) ã¯Canvas(Yä¸‹å‘ã)ä¸Šã§é€²è¡Œæ–¹å‘ã®å³å´ãŒæ­£ã€‚
//   å·¦å´ = nxè² æ–¹å‘ â†’ offset = -(LANE_W/2 + lane * LANE_W)
//   lane0: ä¸­å¤®å¯„ã‚Š(offset = -LANE_W/2)
//   lane1: å¤–å´    (offset = -LANE_W/2 - LANE_W)
let carCounter=0;
class Car {
  constructor(route, img){
    this.id=carCounter++;
    this.route=route;   // [{edge, lane}, ...]
    this.routeIdx=0;
    this.edge=route[0].edge;
    this.lane=route[0].lane;
    this.pos=0.02;
    this.speed=0;
    this.maxSpeed=1+Math.random()*1.2;
    this.wait=0;
    this.img=img;
    this.alive=true;
    this.edge.laneCars[this.lane].push(this);
  }

  update(){
    if(!this.alive) return;
    const laneArr=this.edge.laneCars[this.lane];

    // ===== è»Šç·šå¤‰æ›´ãƒ­ã‚¸ãƒƒã‚¯ =====
    // æ¡ä»¶: main 2è»Šç·š / posç¯„å›²å†… / cooldownçµ‚äº† / éš£è»Šç·šãŒç©ºã„ã¦ã„ã‚‹
    if(this.edge.lanes >= 2 &&
       this.pos > 0.15 && this.pos < 0.80 &&
       (!this.laneChangeCooldown || --this.laneChangeCooldown <= 0)){
      const ahead = laneArr.filter(c=>c.pos>this.pos).sort((a,b)=>a.pos-b.pos)[0];
      const frontGap = ahead ? (ahead.pos-this.pos)*this.edge.length : Infinity;
      // å‰æ–¹ãŒè©°ã¾ã£ã¦ã„ã‚‹å ´åˆã«éš£è»Šç·šã‚’æ¤œè¨
      if(frontGap < SLOW_GAP * 1.8){
        const altLane = 1 - this.lane; // 0â†”1 åˆ‡ã‚Šæ›¿ãˆ
        const altArr  = this.edge.laneCars[altLane];
        const altAhead = altArr.filter(c=>c.pos>this.pos).sort((a,b)=>a.pos-b.pos)[0];
        const altBehind= altArr.filter(c=>c.pos<this.pos).sort((a,b)=>b.pos-a.pos)[0];
        const altFrontGap  = altAhead  ? (altAhead.pos -this.pos)*this.edge.length : Infinity;
        const altBehindGap = altBehind ? (this.pos-altBehind.pos)*this.edge.length : Infinity;
        // éš£è»Šç·šã®å‰å¾Œã«ååˆ†ãªé–“éš”ãŒã‚ã‚Œã°å¤‰æ›´
        if(altFrontGap > frontGap * 1.3 && altBehindGap > MIN_GAP * 1.5){
          laneArr.splice(laneArr.indexOf(this), 1);
          this.lane = altLane;
          this.edge.laneCars[this.lane].push(this);
          // ãƒ«ãƒ¼ãƒˆã®ç¾åœ¨ã‚¹ãƒ†ãƒƒãƒ—ã®è»Šç·šã‚‚æ›´æ–°
          if(this.route[this.routeIdx]) this.route[this.routeIdx].lane = this.lane;
          this.laneChangeCooldown = 90; // ç´„1.5ç§’ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
        }
      }
    }

    // å‰æ–¹è»Šã¨ã®è»Šé–“ã§é€Ÿåº¦æ±ºå®š
    const ahead=laneArr.filter(c=>c.pos>this.pos).sort((a,b)=>a.pos-b.pos)[0];
    let target=this.maxSpeed;
    if(ahead){
      const gap=(ahead.pos-this.pos)*this.edge.length;
      if(gap<MIN_GAP){ target=0; this.wait++; }
      else if(gap<SLOW_GAP) target=this.maxSpeed*(gap/SLOW_GAP);
    }

    // ä¿¡å·åˆ¤å®š: æ¬¡ã®ãƒãƒ¼ãƒ‰(to)ãŒå†…éƒ¨äº¤å·®ç‚¹ãªã‚‰ä¿¡å·ã‚’ç¢ºèª
    const toNode=this.edge.to;
    if(toNode.type==="cross" && !toNode.external){
      if(toNode.hasSignal){
        // é€šå¸¸ã®ä¿¡å·åˆ¤å®š
        if(this.pos>0.85){
          const dx=this.edge.to.x-this.edge.from.x;
          const dy=this.edge.to.y-this.edge.from.y;
          const isVert=Math.abs(dy)>Math.abs(dx);
          const canGo=isVert?(toNode.phase===0):(toNode.phase===1);
          if(!canGo){ target=0; this.wait++; }
        }
      } else {
        // ä¿¡å·ãªã—äº¤å·®ç‚¹: äº¤å·®ç‚¹æ¥è¿‘æ™‚ã«å¾è¡Œã€ä»–æ–¹å‘ã‹ã‚‰æ¥ã‚‹è»ŠãŒã„ã‚Œã°ä¸€æ™‚åœæ­¢
        if(this.pos > 0.65){
          // å¾è¡Œé€Ÿåº¦ã«åˆ¶é™ï¼ˆmaxSpeedã®15%ï¼‰
          target = Math.min(target, this.maxSpeed * 0.15);
          // äº¤å·®ç‚¹ã«å‘ã‹ã†ä»–æ–¹å‘ã®è»ŠãŒè¿‘ãã«ã„ã‚Œã°å®Œå…¨åœæ­¢ã—ã¦è­²ã‚‹
          const crossingCars = cars.filter(c =>
            c !== this &&
            c.alive &&
            c.edge.to === toNode &&
            c.edge !== this.edge &&
            c.pos > 0.60
          );
          if(crossingCars.length > 0){
            // å…ˆã«æ¥ã¦ã„ã‚‹è»Šï¼ˆposãŒå¤§ãã„ï¼‰ã«è­²ã‚‹
            const mustYield = crossingCars.some(c => c.pos > this.pos + 0.05);
            if(mustYield){ target=0; this.wait++; }
          }
        }
      }
    }

    // äº‹æ•…ã‚¾ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯: è¿‘ãã«äº‹æ•…ãŒã‚ã‚Œã°å¼·åˆ¶æ¸›é€Ÿ
    const {from:ef,to:et}=this.edge;
    const carX=ef.x+(et.x-ef.x)*this.pos;
    const carY=ef.y+(et.y-ef.y)*this.pos;
    for(const acc of accidents){
      if(Math.hypot(carX-acc.x, carY-acc.y) < ACCIDENT_SLOWZONE){
        target=Math.min(target, 0.2); // å¾è¡Œ
        this.wait++;
        break;
      }
    }

    this.speed+=(target-this.speed)*0.2;
    this.pos+=this.speed/this.edge.length;
    this.pos=Math.min(this.pos,1);

    if(this.pos>=1){
      const idx=laneArr.indexOf(this);
      if(idx!==-1) laneArr.splice(idx,1);
      this.routeIdx++;
      if(this.routeIdx>=this.route.length){
        if(this.isPolice){
          // ãƒ‘ãƒˆã‚«ãƒ¼ã¯ç¾å ´åˆ°ç€å¾Œã€äº‹æ•…ãŒè§£æ¶ˆã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
          if(this.targetAcc && accidents.includes(this.targetAcc)){
            // äº‹æ•…ç¾å ´ä»˜è¿‘ã«ç•™ã¾ã‚‹ï¼ˆpos=0.5ã§åœæ­¢ï¼‰
            this.targetAcc.policeArrived = true;
            this.speed = 0;
            this.pos = 0.5;
            return; // alive ã®ã¾ã¾
          }
          // äº‹æ•…è§£æ¶ˆ â†’ ãƒ‘ãƒˆã‚«ãƒ¼æ¶ˆæ»…
          this.alive = false;
          return;
        }
        this.alive=false;
        // ç›®çš„åœ°åˆ°ç€ã§ã‚¹ã‚³ã‚¢åŠ ç®—
        score += Math.round(200 * scoreBonus);
        return;
      }
      const next=this.route[this.routeIdx];
      this.edge=next.edge;
      this.lane=next.lane;
      this.pos=0.02;
      this.edge.laneCars[this.lane].push(this);
    }
  }

  draw(){
    if(!this.alive) return;
    const {from,to}=this.edge;
    const vx=to.x-from.x, vy=to.y-from.y;
    const len=Math.sqrt(vx*vx+vy*vy);
    const nx=-vy/len, ny=vx/len;

    // å·¦å´é€šè¡Œ: nxè² æ–¹å‘(é€²è¡Œå·¦å´)ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    const offset=-(LANE_W/2 + this.lane*LANE_W);
    const cx=from.x+vx*this.pos+nx*offset;
    const cy=from.y+vy*this.pos+ny*offset;
    const angle=Math.atan2(vy,vx);

    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(angle);
    if(this.img&&this.img.complete&&this.img.naturalWidth>0){
      ctx.drawImage(this.img,-10,-6,20,12);
    } else {
      ctx.fillStyle = this.isPolice ? "#1a3a8f" : "yellow";
      ctx.fillRect(-6,-4,12,8);
    }
    // ãƒ‘ãƒˆã‚«ãƒ¼ã®ã‚µã‚¤ãƒ¬ãƒ³ç‚¹æ»…ï¼ˆèµ¤/é’äº¤äº’ï¼‰
    if(this.isPolice){
      const siren = Math.floor(timeCounter/8)%2===0;
      ctx.fillStyle = siren ? "rgba(255,30,30,0.85)" : "rgba(30,80,255,0.85)";
      ctx.beginPath();
      ctx.arc(0, -7, 3, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
}


// ===== éƒ½å¸‚ç”Ÿæˆ =====
// è¨­è¨ˆ:
//  1. å¹¹ç·š(arterial): æ°´å¹³2ã€œ3æœ¬ + å‚ç›´2ã€œ3æœ¬ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
//     â†’ äº¤ç‚¹ã‚’è‡ªå‹•è¨ˆç®—ã—ãƒãƒ¼ãƒ‰åŒ– â†’ å¤šæ§˜ãªæ§‹é€ ãƒ‘ã‚¿ãƒ¼ãƒ³
//  2. æ”¯ç·š(branch): ä¸»è¦é“è·¯ã®ã€Œé€”ä¸­ã€ã‹ã‚‰Tå­—è·¯ã¨ã—ã¦æåˆ†ã‹ã‚Œ
//     â†’ ã‚¨ãƒƒã‚¸ã‚’ä¸­é–“ãƒãƒ¼ãƒ‰ã§åˆ†å‰²ã—ã€ãã“ã‹ã‚‰å‚ç›´æ–¹å‘ã«ä¼¸ã°ã™
//  å…¨ã‚¨ãƒƒã‚¸ã¯ä¸€æ–¹é€šè¡Œãƒšã‚¢(Aâ†’B ã¨ Bâ†’A)ã€‚

function generateCity(){
  nodes.length=0; edges.length=0; cars.length=0;
  accidents.length=0; policeCars.length=0; score=0; budget=0; scoreBonus=1.0; bonusStreak=0; accidentCount=0;

  // ================================================================
  // ãƒ˜ãƒ«ãƒ‘ãƒ¼
  // ================================================================
  function mkNode(x,y,type="cross",ext=false,img=null){
    const n=new Node(x,y,type,ext,img); nodes.push(n); return n;
  }

  // ç‚¹pã‹ã‚‰ç·šåˆ†(a,b)ã¸ã®è·é›¢
  function ptSegDist(p,a,b){
    const dx=b.x-a.x,dy=b.y-a.y,l2=dx*dx+dy*dy;
    if(l2===0) return Math.hypot(p.x-a.x,p.y-a.y);
    const t=Math.max(0,Math.min(1,((p.x-a.x)*dx+(p.y-a.y)*dy)/l2));
    return Math.hypot(p.x-a.x-dx*t, p.y-a.y-dy*t);
  }

  // ã‚¨ãƒƒã‚¸è¿½åŠ ã®å³å¯†ãƒã‚§ãƒƒã‚¯
  // â‘  æœ€å°é•·  â‘¡ é‡è¤‡  â‘¢ äº¤å·®ï¼ˆsegmentsCrossï¼‰  â‘£ Tå­—æ¥è§¦é˜²æ­¢  â‘¤ è¿‘æ¥å¹³è¡Œ
  function canAdd(a,b,minLen=50){
    if(Math.hypot(b.x-a.x,b.y-a.y)<minLen) return false;
    // â‘¡ é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if(edges.some(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a))) return false;
    const vx=b.x-a.x,vy=b.y-a.y,vl=Math.hypot(vx,vy);
    for(const e of edges){
      // â‘¢ å³å¯†ãªäº¤å·®ãƒã‚§ãƒƒã‚¯ï¼ˆXå­—ãƒ»Tå­—ã®ä¸­é–“äº¤å·®ã‚’å…¨ã¦æ¤œå‡ºï¼‰
      if(segmentsCross(a,b,e.from,e.to)) return false;

      // â‘£ Tå­—æ¥è§¦é˜²æ­¢:
      //    æ–°ã‚¨ãƒƒã‚¸ã®ç«¯ç‚¹ a,b ãŒæ—¢å­˜ã‚¨ãƒƒã‚¸ e ã®ã€Œä¸­é–“éƒ¨åˆ†ã€ã«è¿‘ã„å ´åˆã¯NG
      //    ï¼ˆç«¯ç‚¹=ãƒãƒ¼ãƒ‰ãŒé“è·¯ã®é€”ä¸­ã«åˆºã•ã‚‹ã®ã‚’é˜²ãï¼‰
      //    ãŸã ã— a,b ãŒ e.from ã¾ãŸã¯ e.to ãã®ã‚‚ã®ã§ã‚ã‚‹å ´åˆã¯OKï¼ˆæ¥ç¶šç‚¹ï¼‰
      if(a!==e.from && a!==e.to){
        if(ptSegDist(a,e.from,e.to) < 12) return false;
      }
      if(b!==e.from && b!==e.to){
        if(ptSegDist(b,e.from,e.to) < 12) return false;
      }

      // â‘¤ è¿‘æ¥å¹³è¡Œãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡é“è·¯é˜²æ­¢ï¼‰
      const ex=e.to.x-e.from.x,ey=e.to.y-e.from.y,el=Math.hypot(ex,ey);
      if(el<1) continue;
      if(Math.abs((vx*ex+vy*ey)/(vl*el))<0.90) continue;
      const near=[0.25,0.5,0.75].some(t=>{
        const px=a.x+vx*t, py=a.y+vy*t;
        return ptSegDist({x:px,y:py},e.from,e.to)<38;
      });
      if(near) return false;
    }
    return true;
  }

  function addPair(a,b,type){
    if(!canAdd(a,b)) return false;
    edges.push(new Edge(a,b,type));
    edges.push(new Edge(b,a,type));
    return true;
  }

  // 2ç·šåˆ†ã®äº¤ç‚¹ã‚’è¨ˆç®—ï¼ˆå¹³è¡Œãƒ»éäº¤å·®æ™‚ã¯nullï¼‰
  function segIntersection(p1,p2,p3,p4){
    const d1x=p2.x-p1.x, d1y=p2.y-p1.y;
    const d2x=p4.x-p3.x, d2y=p4.y-p3.y;
    const cross=d1x*d2y-d1y*d2x;
    if(Math.abs(cross)<0.001) return null;
    const t=((p3.x-p1.x)*d2y-(p3.y-p1.y)*d2x)/cross;
    const u=((p3.x-p1.x)*d1y-(p3.y-p1.y)*d1x)/cross;
    if(t<0.05||t>0.95||u<0.05||u>0.95) return null; // ç«¯ç‚¹ä»˜è¿‘ã¯é™¤å¤–
    return {x:p1.x+d1x*t, y:p1.y+d1y*t};
  }

  // ================================================================
  // 1. å¹¹ç·š(arterial) â€” æ°´å¹³ç·šãƒ»å‚ç›´ç·šã‚’ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ã—ã¦äº¤ç‚¹ãƒãƒ¼ãƒ‰ç”Ÿæˆ
  // ================================================================

  // æ°´å¹³ç·š: 2ã€œ3æœ¬ã€yåº§æ¨™ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
  const numH=2+Math.floor(Math.random()*2);  // 2ã€œ3æœ¬
  const numV=2+Math.floor(Math.random()*2);  // 2ã€œ3æœ¬

  // yåº§æ¨™: 150ã€œ560ã®ç¯„å›²ã§å‡ç­‰åˆ†å‰²ï¼‹ãƒ©ãƒ³ãƒ€ãƒ ã‚¸ãƒƒã‚¿ãƒ¼
  function randLines(count, lo, hi){
    const step=(hi-lo)/(count+1);
    return Array.from({length:count},(_,i)=>
      Math.round(lo+step*(i+1)+(Math.random()-0.5)*step*0.4)
    );
  }
  const hYs=randLines(numH,130,570);  // æ°´å¹³ç·šã®yåº§æ¨™
  const vXs=randLines(numV,180,820);  // å‚ç›´ç·šã®xåº§æ¨™

  // å„æ°´å¹³ãƒ»å‚ç›´ç·šã‚’ã€Œç„¡é™é•·ã®ç›´ç·šã€ã¨ã—ã¦å®šç¾©ã—ã€å¾Œã§äº¤ç‚¹ã§ãƒãƒ¼ãƒ‰åŒ–
  // æ°´å¹³ç·š: y=hY, x: 0â†’1000
  // å‚ç›´ç·š: x=vX, y: 0â†’700

  // ----------------------------------------------------------------
  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ç”Ÿæˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
  //  ãƒ‘ã‚¿ãƒ¼ãƒ³Aï¼ˆ40%ï¼‰: å…¨å¹¹ç·šã«å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚ã‚Šï¼ˆå¾“æ¥é€šã‚Šï¼‰
  //  ãƒ‘ã‚¿ãƒ¼ãƒ³Bï¼ˆ35%ï¼‰: ä¸€éƒ¨ã®å¹¹ç·šç«¯ã®ã¿å¤–éƒ¨ãƒãƒ¼ãƒ‰ï¼ˆé–“å¼•ãï¼‰
  //  ãƒ‘ã‚¿ãƒ¼ãƒ³Cï¼ˆ25%ï¼‰: å¤–éƒ¨ãƒãƒ¼ãƒ‰ãŒéå¸¸ã«å°‘ãªã„ï¼ˆå†…å´ã®éƒ½å¸‚ã®ã¿ï¼‰
  // ----------------------------------------------------------------
  const extPattern = Math.random();
  // å„ç«¯ç‚¹ã«å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚’ä½œã‚‹ã‹æ±ºã‚ã‚‹é–¢æ•°
  function shouldMakeExt(patternRoll){
    if(patternRoll < 0.40) return true;          // ãƒ‘ã‚¿ãƒ¼ãƒ³A: å…¨éƒ¨ä½œã‚‹
    if(patternRoll < 0.75) return Math.random() < 0.55; // ãƒ‘ã‚¿ãƒ¼ãƒ³B: 55%ã§ä½œã‚‹
    return Math.random() < 0.25;                 // ãƒ‘ã‚¿ãƒ¼ãƒ³C: 25%ã§ä½œã‚‹
  }

  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚’å¹¹ç·šã®ç«¯ç‚¹ã¨ã—ã¦ä½œæˆï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¿œã˜ã¦é–“å¼•ãï¼‰
  const hExtL=hYs.map(y=> shouldMakeExt(extPattern) ? mkNode(0,   y,"cross",true) : null);
  const hExtR=hYs.map(y=> shouldMakeExt(extPattern) ? mkNode(1000,y,"cross",true) : null);
  const vExtT=vXs.map(x=> shouldMakeExt(extPattern) ? mkNode(x,  0,"cross",true) : null);
  const vExtB=vXs.map(x=> shouldMakeExt(extPattern) ? mkNode(x,700,"cross",true) : null);

  // äº¤ç‚¹ãƒãƒ¼ãƒ‰ãƒãƒˆãƒªã‚¯ã‚¹: crossPt[hi][vi] = {x,y} ã®äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰
  const crossPt=hYs.map((hy,hi)=>
    vXs.map((vx,vi)=>mkNode(vx,hy,"cross"))
  );

  // æ°´å¹³å¹¹ç·šã‚’å„è¡Œã§å·¦ç«¯â†’äº¤ç‚¹â†’â€¦â†’å³ç«¯ã¨ã‚¨ãƒƒã‚¸ã§ç¹‹ãï¼ˆå¤–éƒ¨ãƒãƒ¼ãƒ‰ãŒnullãªã‚‰ç«¯ç‚¹ã¾ã§å»¶ã°ã•ãªã„ï¼‰
  for(let hi=0;hi<numH;hi++){
    const row=[hExtL[hi], ...crossPt[hi], hExtR[hi]].filter(n=>n!==null);
    for(let i=0;i<row.length-1;i++) addPair(row[i],row[i+1],"main");
  }
  // å‚ç›´å¹¹ç·šã‚’å„åˆ—ã§ä¸Šç«¯â†’äº¤ç‚¹â†’â€¦â†’ä¸‹ç«¯ã¨ã‚¨ãƒƒã‚¸ã§ç¹‹ã
  for(let vi=0;vi<numV;vi++){
    const col=[vExtT[vi], ...crossPt.map(r=>r[vi]), vExtB[vi]].filter(n=>n!==null);
    for(let i=0;i<col.length-1;i++) addPair(col[i],col[i+1],"main");
  }

  // ================================================================
  // 2. æ”¯ç·š(branch) â€” 2ç¨®é¡ã®ç”Ÿæˆæ–¹æ³•
  //
  //  [A] é“è·¯ã®é€”ä¸­ã‹ã‚‰Tå­—è·¯: ä¸»è¦é“è·¯ã‚¨ãƒƒã‚¸ã‚’ä¸­é–“ãƒãƒ¼ãƒ‰ã§åˆ†å‰²ã—ã€
  //      ãã“ã‹ã‚‰å‚ç›´æ–¹å‘ã«æ”¯ç·šã‚’ä¼¸ã°ã™
  //  [B] æ—¢å­˜äº¤å·®ç‚¹ã‹ã‚‰æ–œã‚æ–¹å‘ã«ä¼¸ã°ã—ã€åˆ¥ã®äº¤å·®ç‚¹ã¸æ¥ç¶š
  // ================================================================

  // [A] é“è·¯é€”ä¸­ã‹ã‚‰Tå­—è·¯æ”¯ç·š
  // æ—¢å­˜mainã‚¨ãƒƒã‚¸ã®ã†ã¡ååˆ†é•·ã„ã‚‚ã®ã‚’é¸ã³ã€ä¸­é–“ã«åˆ†å²ç‚¹ã‚’ä½œã‚‹
  function splitEdgeAndBranch(){
    // ç¾æ™‚ç‚¹ã®mainã‚¨ãƒƒã‚¸ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆåˆ†å‰²ä¸­ã«edgesãŒå¤‰åŒ–ã™ã‚‹ãŸã‚ï¼‰
    const mainEdges=edges.filter(e=>e.type==="main"&&e.length>180);
    // ãƒ©ãƒ³ãƒ€ãƒ ã«æ•°æœ¬é¸ã‚“ã§è©¦ã¿ã‚‹
    const targets=[...mainEdges].sort(()=>Math.random()-0.5).slice(0,4);

    for(const e of targets){
      if(Math.random()<0.4) continue; // 60%ã®ç¢ºç‡ã§è©¦ã¿ã‚‹

      // ä¸­é–“ç‚¹ã‚’25ã€œ75%ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
      const t=0.3+Math.random()*0.4;
      const mx=e.from.x+(e.to.x-e.from.x)*t;
      const my=e.from.y+(e.to.y-e.from.y)*t;

      // è¿‘ã™ãã‚‹æ—¢å­˜ãƒãƒ¼ãƒ‰ãŒã‚ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
      if(nodes.some(n=>n.type==="cross"&&Math.hypot(n.x-mx,n.y-my)<80)) continue;

      // ã‚¨ãƒƒã‚¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
      const vx=e.to.x-e.from.x, vy=e.to.y-e.from.y;
      const len=Math.hypot(vx,vy);
      // å‚ç›´æ–¹å‘ï¼ˆå·¦å³ã©ã¡ã‚‰ã‹ï¼‰
      const side=Math.random()<0.5?1:-1;
      const nx=-vy/len*side, ny=vx/len*side;
      const bLen=100+Math.random()*80;
      const tx=Math.max(30,Math.min(970, mx+nx*bLen));
      const ty=Math.max(30,Math.min(670, my+ny*bLen));

      // åˆ†å²ç‚¹ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
      const mid=mkNode(mx,my,"cross");

      // å…ƒã®ã‚¨ãƒƒã‚¸ã‚’åˆ†å‰²: fromâ†’mid ã¨ midâ†’to
      // å…ƒã‚¨ãƒƒã‚¸ã‚’å‰Šé™¤ã—ã¦2åˆ†å‰²
      const iFrom=edges.indexOf(e);
      const ePair=edges.find(ep=>ep.from===e.to&&ep.to===e.from);
      if(iFrom===-1) { nodes.splice(nodes.indexOf(mid),1); continue; }
      edges.splice(iFrom,1);
      if(ePair) edges.splice(edges.indexOf(ePair),1);

      // åˆ†å‰²ã‚¨ãƒƒã‚¸è¿½åŠ ï¼ˆcanAddä¸è¦: å…ƒã‚¨ãƒƒã‚¸ã®éƒ¨åˆ†ãªã®ã§äº¤å·®ãªã—ï¼‰
      edges.push(new Edge(e.from,mid,"main"));
      edges.push(new Edge(mid,e.from,"main"));
      edges.push(new Edge(mid,e.to,"main"));
      edges.push(new Edge(e.to,mid,"main"));

      // æ”¯ç·šæœ«ç«¯ãƒãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦è¿½åŠ 
      const term=mkNode(tx,ty,"cross");
      if(canAdd(mid,term,60)){
        edges.push(new Edge(mid,term,"branch"));
        edges.push(new Edge(term,mid,"branch"));
        // æœ«ç«¯ã‹ã‚‰ã•ã‚‰ã«è¿‘éš£äº¤å·®ç‚¹ã¸æ¥ç¶šã§ãã‚Œã°é€šã‚ŠæŠœã‘ã«
        const allC=nodes.filter(n=>n.type==="cross"&&!n.external&&n!==mid&&n!==term);
        const nb=allC
          .filter(m=>Math.hypot(m.x-tx,m.y-ty)<200)
          .sort((a,b)=>Math.hypot(a.x-tx,a.y-ty)-Math.hypot(b.x-tx,b.y-ty))[0];
        if(nb&&canAdd(term,nb,50)) addPair(term,nb,"branch");
      } else {
        nodes.splice(nodes.indexOf(term),1);
      }
    }
  }
  splitEdgeAndBranch();

  // [B] æ—¢å­˜äº¤å·®ç‚¹ã‹ã‚‰æ”¯ç·šã‚’ä¼¸ã°ã™ï¼ˆsplitEdgeAndBranchå¾Œã«å†å–å¾—ã—ã¦æ–°ãƒãƒ¼ãƒ‰ã‚‚å«ã‚ã‚‹ï¼‰
  const allCross=nodes.filter(n=>n.type==="cross"&&!n.external);

  function existingAngles(node){
    return edges.filter(e=>e.from===node)
      .map(e=>Math.atan2(e.to.y-node.y,e.to.x-node.x));
  }
  function angleFarEnough(angle,existing){
    return existing.every(a=>{
      let d=Math.abs(angle-a)%(2*Math.PI);
      if(d>Math.PI) d=2*Math.PI-d;
      return d>Math.PI/12; // 15åº¦ä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚Œã°å¯
    });
  }

  for(const n of allCross){
    if(edges.some(e=>e.from===n&&e.type==="branch")) continue;
    if(Math.random()<0.5) continue; // 50%ã§è©¦ã¿ã‚‹
    const exAngles=existingAngles(n);
    const bLen=100+Math.random()*100;
    const angles=Array.from({length:16},(_,i)=>i*(Math.PI/8)).sort(()=>Math.random()-0.5);

    for(const angle of angles){
      if(!angleFarEnough(angle,exAngles)) continue;
      const tx=Math.max(30,Math.min(970, n.x+Math.cos(angle)*bLen));
      const ty=Math.max(30,Math.min(670, n.y+Math.sin(angle)*bLen));

      // è¿‘ãã«æ—¢å­˜äº¤å·®ç‚¹ãŒã‚ã‚Œã°ãã“ã¸æ¥ç¶šï¼ˆé€šã‚ŠæŠœã‘ï¼‰
      const snap=allCross.find(m=>m!==n&&Math.hypot(m.x-tx,m.y-ty)<80);
      if(snap){ if(addPair(n,snap,"branch")) break; continue; }

      const term=mkNode(tx,ty,"cross");
      if(canAdd(n,term,80)){
        edges.push(new Edge(n,term,"branch"));
        edges.push(new Edge(term,n,"branch"));
        // æœ«ç«¯ã‹ã‚‰ã‚‚åˆ¥äº¤å·®ç‚¹ã¸ç¹‹ã’ã‚‹ã‹è©¦ã¿ã‚‹
        const nb=allCross
          .filter(m=>m!==n&&Math.hypot(m.x-tx,m.y-ty)<200)
          .sort((a,b)=>Math.hypot(a.x-tx,a.y-ty)-Math.hypot(b.x-tx,b.y-ty))[0];
        if(nb&&canAdd(term,nb,50)) addPair(term,nb,"branch");
        break;
      } else {
        nodes.splice(nodes.indexOf(term),1);
      }
    }
  }

  // ================================================================
  // [C] æ”¯ç·šã®ä¸€éƒ¨ã‚’onewayã«å¤‰æ›ï¼ˆç´„30%ï¼‰
  // onewayã¯é€†å‘ãã‚¨ãƒƒã‚¸ã‚’æŒãŸãªã„çœŸã®ä¸€æ–¹é€šè¡Œã€‚
  // å¯¾è±¡: branchå‹ã‚¨ãƒƒã‚¸ã®ãƒšã‚¢ã®ã†ã¡ã€ãƒ©ãƒ³ãƒ€ãƒ ã«ç‰‡æ–¹ã‚’å‰Šé™¤ã—ã¦onewayã«ã™ã‚‹
  {
    // branchã‚¨ãƒƒã‚¸ã‚’ãƒšã‚¢å˜ä½ã§å–å¾—ï¼ˆAâ†’B ã¨ Bâ†’A ã®çµ„ï¼‰
    const branchPairs=new Set();
    const toRemove=[];
    for(const e of edges){
      if(e.type!=="branch") continue;
      const key=[e.from,e.to].map(n=>nodes.indexOf(n)).sort().join("-");
      if(branchPairs.has(key)) continue;
      branchPairs.add(key);
      // å¤–éƒ¨ãƒãƒ¼ãƒ‰ãŒçµ¡ã‚€ã‚¨ãƒƒã‚¸ã¯onewayä¸å¯ï¼ˆé€²å…¥ãƒ»é€€å‡ºãŒå£Šã‚Œã‚‹ï¼‰
      if(e.from.external||e.to.external) continue;
      if(Math.random()<0.30){
        // ã“ã®ãƒšã‚¢ã‚’onewayã«: é€†å‘ãã‚¨ãƒƒã‚¸ã‚’å‰Šé™¤ã—ã¦æ®‹ã‚Šã‚’onewayã«å¤‰æ›´
        const rev=edges.find(r=>r.from===e.to&&r.to===e.from&&r.type==="branch");
        if(rev){
          toRemove.push(rev);
          e.type="oneway";
        }
      }
    }
    for(const r of toRemove) edges.splice(edges.indexOf(r),1);
  }

  // ================================================================
  // [D] å¤–éƒ¨ãƒãƒ¼ãƒ‰ã¸ã®è¿½åŠ æ¥ç¶š
  // ----------------------------------------------------------------
  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ã”ã¨ã«ã€ä»¥ä¸‹ã®3ã‚¿ã‚¤ãƒ—ã‚’ãƒãƒ©ãƒ³ã‚¹ã‚ˆãè¿½åŠ æ¥ç¶šã™ã‚‹ã€‚
  //  - "main"  (2è»Šç·šåŒæ–¹å‘): 35%
  //  - "branch"(1è»Šç·šåŒæ–¹å‘): 35%
  //  - "oneway"(1è»Šç·šä¸€æ–¹å‘): 30%
  //
  // â˜… ãƒã‚°ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ:
  //   å¤–éƒ¨ãƒãƒ¼ãƒ‰(x=0, x=1000, y=0, y=700)ã‹ã‚‰å†…éƒ¨äº¤å·®ç‚¹ã¸ã®ç·šåˆ†ã¯
  //   å¿…ãšæ—¢å­˜å¹¹ç·šã‚¨ãƒƒã‚¸ã¨äº¤å·®ã™ã‚‹ãŸã‚ã€é€šå¸¸ã® canAdd() ã§ã¯å…¨ã¦å¼¾ã‹ã‚Œã‚‹ã€‚
  //   â†’ å¤–éƒ¨ãƒãƒ¼ãƒ‰å°‚ç”¨ã® canAddExt() ã‚’ä½¿ç”¨:
  //      é‡è¤‡ãƒã‚§ãƒƒã‚¯ã®ã¿è¡Œã„ã€äº¤å·®ãƒ»è¿‘æ¥å¹³è¡Œãƒã‚§ãƒƒã‚¯ã¯çœç•¥ã™ã‚‹ã€‚
  //      ãŸã ã—åŒä¸€æ–¹å‘ã«æ—¢ã«ã‚¨ãƒƒã‚¸ãŒã‚ã‚‹å ´åˆï¼ˆä¸¦èµ°ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—ã€‚
  {
    // å¤–éƒ¨ãƒãƒ¼ãƒ‰å°‚ç”¨ãƒã‚§ãƒƒã‚¯
    // å¤–éƒ¨â†’å†…éƒ¨ã®ç·šåˆ†ã¯å¹¹ç·šã‚’ã€Œé€šéã€ã™ã‚‹ãŸã‚é€šå¸¸ã®linesIntersectã§ã¯å…¨ã¦å¼¾ã‹ã‚Œã‚‹ã€‚
    // ãŸã ã—å¹¹ç·šã®ç«¯ç‚¹(å¤–éƒ¨ãƒãƒ¼ãƒ‰)ã¨å…±æœ‰æ¥ç¶šã™ã‚‹äº¤å·®ã¯OKã¨ã—ã€
    // ãã‚Œä»¥å¤–ã®ã€ŒçœŸã®äº¤å·®ã€ï¼ˆæ”¯ç·šã‚„ä»–ã®å¹¹ç·šã¨ã®ä¸­é–“ã‚¯ãƒ­ã‚¹ï¼‰ã¯å¼¾ãã€‚
    function canAddExt(a, b, minLen=50){
      if(Math.hypot(b.x-a.x,b.y-a.y) < minLen) return false;
      if(edges.some(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a))) return false;
      const vx=b.x-a.x, vy=b.y-a.y, vl=Math.hypot(vx,vy);
      for(const e of edges){
        // å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚’å…±æœ‰ã—ã¦ã„ã‚‹å¹¹ç·šã¨ã®äº¤å·®ã¯OKï¼ˆç«¯ç‚¹æ¥ç¶šã®ãŸã‚ï¼‰
        // ãŸã ã—æ”¯ç·šãƒ»onewayã¨ã®äº¤å·®ã¯NG
        const shareNode = (a===e.from||a===e.to||b===e.from||b===e.to);
        if(!shareNode){
          // çœŸã®äº¤å·®ãƒã‚§ãƒƒã‚¯ï¼ˆsegmentsCrossä½¿ç”¨ï¼‰
          if(segmentsCross(a,b,e.from,e.to)) return false;
          // Tå­—æ¥è§¦é˜²æ­¢: bãŒæ—¢å­˜ã‚¨ãƒƒã‚¸ã®ä¸­é–“ã«åˆºã•ã‚‹ã®ã‚’é˜²ã
          if(b!==e.from && b!==e.to && ptSegDist(b,e.from,e.to)<12) return false;
        }
        // è¿‘æ¥å¹³è¡Œãƒã‚§ãƒƒã‚¯ï¼ˆä¸¦èµ°é˜²æ­¢ï¼‰
        const ex=e.to.x-e.from.x, ey=e.to.y-e.from.y, el=Math.hypot(ex,ey);
        if(el<1) continue;
        if(Math.abs((vx*ex+vy*ey)/(vl*el)) < 0.90) continue;
        const near=[0.4,0.6].some(t=>{
          const px=a.x+vx*t, py=a.y+vy*t;
          return ptSegDist({x:px,y:py},e.from,e.to)<30;
        });
        if(near) return false;
      }
      return true;
    }

    function addPairExt(a, b, type){
      if(!canAddExt(a,b)) return false;
      edges.push(new Edge(a,b,type));
      edges.push(new Edge(b,a,type));
      return true;
    }

    const extList = nodes.filter(n => n.external && n.type === "cross");
    const intList = nodes.filter(n => n.type === "cross" && !n.external);

    for(const ext of extList){
      if(Math.random() < 0.40) continue; // 60%ã®å¤–éƒ¨ãƒãƒ¼ãƒ‰ã§è©¦ã¿ã‚‹

      // æ¥ç¶šã‚¿ã‚¤ãƒ—ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
      const roll = Math.random();
      const connType = roll < 0.35 ? "main" : roll < 0.70 ? "branch" : "oneway";

      // æ—¢ã«mainã§ç¹‹ãŒã£ã¦ã„ã‚‹äº¤å·®ç‚¹ã‚’é™¤ã„ãŸå€™è£œã‚’è·é›¢é †ã§ä¸¦ã¹ã‚‹
      const cands = intList
        .filter(n => {
          const d = Math.hypot(n.x-ext.x, n.y-ext.y);
          return d > 60 && d < 450;
        })
        .filter(n => {
          // æ—¢ã«ä½•ã‚‰ã‹ã®ã‚¨ãƒƒã‚¸ã§ç¹‹ãŒã£ã¦ã„ã‚‹ãƒšã‚¢ã¯ã‚¹ã‚­ãƒƒãƒ—
          return !edges.some(e =>
            (e.from===ext && e.to===n) || (e.from===n && e.to===ext)
          );
        })
        .sort((a,b) => Math.hypot(a.x-ext.x,a.y-ext.y) - Math.hypot(b.x-ext.x,b.y-ext.y));

      for(const cand of cands){
        if(connType === "oneway"){
          if(!canAddExt(ext, cand, 50)) continue;
          if(Math.random() < 0.5){
            edges.push(new Edge(ext,  cand, "oneway")); // é€²å…¥
          } else {
            edges.push(new Edge(cand, ext,  "oneway")); // é€€å‡º
          }
          break;
        } else {
          if(addPairExt(ext, cand, connType)) break;
        }
      }
    }
  }

  // ================================================================
  // 3. å»ºç‰©ãƒ»å…¬åœ’ãƒ»ä¼šç¤¾ï¼ˆè£…é£¾ï¼‰
  // ================================================================
  // é…ç½®ãƒã‚§ãƒƒã‚¯:
  //   â‘  å…ƒã‚¨ãƒƒã‚¸ã‹ã‚‰é©åˆ‡ãªè·é›¢ï¼ˆé“è·¯å¹…ã®åŠåˆ† + å»ºç‰©åŠå¾„ + ä½™ç™½ï¼‰ã ã‘é›¢ã™
  //   â‘¡ å…¨ã‚¨ãƒƒã‚¸ã¨ã®æœ€çŸ­è·é›¢ãŒ MIN_BLDG_DIST ä»¥ä¸Šã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
  //   â‘¢ æ—¢å­˜å»ºç‰©ãƒãƒ¼ãƒ‰ã¨ã‚‚ä¸€å®šè·é›¢ã‚’ä¿ã¤
  {
    const BLDG_HALF  = 26;  // å»ºç‰©ç”»åƒã®è¡¨ç¤ºåŠå¾„ï¼ˆ50pxç”»åƒã®åŠåˆ†ï¼‹ä½™ç™½ï¼‰
    const MIN_BLDG_DIST = 28; // å»ºç‰©ä¸­å¿ƒã€œã‚¨ãƒƒã‚¸ä¸­å¿ƒç·šã®æœ€å°è·é›¢

    // å…¨ã‚¨ãƒƒã‚¸ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯é–¢æ•°
    function bldgClearOfRoads(bx, by){
      for(const e2 of edges){
        const evx=e2.to.x-e2.from.x, evy=e2.to.y-e2.from.y;
        const el=Math.hypot(evx,evy);
        if(el<1) continue;
        const et=Math.max(0,Math.min(1,((bx-e2.from.x)*evx+(by-e2.from.y)*evy)/(el*el)));
        const dist=Math.hypot(bx-(e2.from.x+evx*et), by-(e2.from.y+evy*et));
        // é“è·¯å¹…ã®åŠåˆ† + å»ºç‰©åŠå¾„ + ä½™ç™½ ã‚ˆã‚Šè¿‘ã‘ã‚Œã°NG
        if(dist < e2.lanes*LANE_W + BLDG_HALF) return false;
      }
      return true;
    }

    const drawnPairs=new Set();
    for(const e of edges){
      const key=[e.from,e.to].map(n=>`${Math.round(n.x)},${Math.round(n.y)}`).sort().join("|");
      if(drawnPairs.has(key)) continue;
      drawnPairs.add(key);
      if(Math.random()>0.4) continue;

      // ä¸¡å´ï¼ˆ+/-ï¼‰ã‚’è©¦ã—ã¦é“è·¯ã‹ã‚‰é›¢ã‚ŒãŸå´ã‚’é¸ã¶
      let placed = false;
      for(const sign of [1,-1].sort(()=>Math.random()-0.5)){
        const t=0.2+Math.random()*0.6;
        const roadHalf = e.lanes*LANE_W; // åŒæ–¹å‘è€ƒæ…®: ç‰‡å´ã®é“è·¯å¹…
        // ã‚ªãƒ•ã‚»ãƒƒãƒˆ = é“è·¯ä¸­å¿ƒç·šã‹ã‚‰ã€Œé“è·¯å¹… + å»ºç‰©åŠå¾„ + ä½™ç™½ã€ã ã‘é›¢ã™
        const offset = roadHalf + BLDG_HALF + 8 + Math.random()*12;
        const vx=e.to.x-e.from.x, vy=e.to.y-e.from.y;
        const len=Math.sqrt(vx*vx+vy*vy);
        const bx=e.from.x+vx*t+(-vy/len)*sign*offset;
        const by=e.from.y+vy*t+(vx/len)*sign*offset;

        if(bx<15||bx>985||by<15||by>685) continue;

        // å…¨ã‚¨ãƒƒã‚¸ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯
        if(!bldgClearOfRoads(bx, by)) continue;

        // æ—¢å­˜å»ºç‰©ãƒãƒ¼ãƒ‰ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯
        const tooClose = nodes.some(n=>
          (n.type==="house"||n.type==="park"||n.type==="company") &&
          Math.hypot(n.x-bx,n.y-by) < BLDG_HALF*2
        );
        if(tooClose) continue;

        const roll=Math.random();
        let type, img;
        if(roll<0.60){      type="house";   img=houseImgs[Math.floor(Math.random()*houseImgs.length)]; }
        else if(roll<0.85){ type="company"; img=companyImgs[Math.floor(Math.random()*companyImgs.length)]; }
        else{               type="park";    img=parkImg; }
        nodes.push(new Node(bx,by,type,false,img));
        placed = true;
        break;
      }
    }
  }

  // ================================================================
  // 3b. é§è»Šå ´ã®é…ç½®
  // ================================================================
  // é…ç½®ãƒ«ãƒ¼ãƒ«:
  //  - å…¨ã‚¨ãƒƒã‚¸(mainå«ã‚€)ã‹ã‚‰å€™è£œã‚’é¸ã¶ãŒã€é“è·¯å¹…ã‚’æ­£ç¢ºã«è€ƒæ…®ã—ãŸè·é›¢ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  //  - é§è»Šå ´ä¸­å¿ƒ(30pxåŠå¾„)ãŒå…¨æ—¢å­˜ã‚¨ãƒƒã‚¸ã‹ã‚‰ç¢ºå®Ÿã«é›¢ã‚Œã¦ã„ã‚‹ã‹æ¤œè¨¼ã—ã¦ã‹ã‚‰é…ç½®
  //  - æ—¢å­˜ãƒãƒ¼ãƒ‰ãƒ»ä»–ã®é§è»Šå ´ã¨ã‚‚ååˆ†ãªé–“éš”ã‚’ç¢ºä¿
  {
    const parkingCount = 3 + Math.floor(Math.random()*4); // 3ã€œ6 ç®‡æ‰€
    const placedParking = [];
    const MIN_PARKING_DIST = 90; // é§è»Šå ´åŒå£«ãƒ»æ—¢å­˜ãƒãƒ¼ãƒ‰ã¨ã®æœ€å°è·é›¢
    const PARKING_RADIUS = 35;   // é§è»Šå ´ã®è¡¨ç¤ºåŠå¾„ï¼ˆ60pxç”»åƒã®åŠåˆ†+ä½™ç™½ï¼‰

    // å…¨ã‚¨ãƒƒã‚¸ã‹ã‚‰å€™è£œã‚’å–ã‚‹ï¼ˆmainã‚‚å«ã‚ã‚‹ï¼‰
    const candEdges = [...edges].sort(()=>Math.random()-0.5);

    for(const e of candEdges){
      if(placedParking.length >= parkingCount) break;
      if(e.from.external || e.to.external) continue; // å¤–éƒ¨ãƒãƒ¼ãƒ‰æ¥ç¶šã‚¨ãƒƒã‚¸ã¯é™¤å¤–

      const vx = e.to.x-e.from.x, vy = e.to.y-e.from.y;
      const len = Math.hypot(vx,vy);
      if(len < 80) continue;

      const t = 0.25 + Math.random()*0.5;  // ä¸­é–“éƒ¨åˆ†ã‹ã‚‰é¸ã¶
      const nx = -vy/len, ny = vx/len;     // ã‚¨ãƒƒã‚¸ã®æ³•ç·šï¼ˆå·¦å³æ–¹å‘ï¼‰

      // é“è·¯å¹…ã®åŠåˆ† + é§è»Šå ´åŠå¾„ + ä½™ç™½ = ç¢ºå®Ÿã«é“è·¯ã«é‡ãªã‚‰ãªã„è·é›¢
      const roadHalfW = e.lanes * LANE_W / 2;
      const safeOffset = roadHalfW + PARKING_RADIUS + 12; // ä½™ç™½12px

      for(const side of [1, -1]){
        const px = e.from.x + vx*t + nx*side*safeOffset;
        const py = e.from.y + vy*t + ny*side*safeOffset;

        // ç”»é¢å¤–ãƒã‚§ãƒƒã‚¯
        if(px < 40 || px > 960 || py < 40 || py > 660) continue;

        // å…¨ã‚¨ãƒƒã‚¸ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆé“è·¯å¹…+é§è»Šå ´åŠå¾„+ä½™ç™½ã‚ˆã‚Šè¿‘ã‘ã‚Œã°NGï¼‰
        const onRoad = edges.some(e2 => {
          const evx=e2.to.x-e2.from.x, evy=e2.to.y-e2.from.y, el=Math.hypot(evx,evy);
          if(el<1) return false;
          const et=Math.max(0,Math.min(1,((px-e2.from.x)*evx+(py-e2.from.y)*evy)/(el*el)));
          const dist=Math.hypot(px-(e2.from.x+evx*et), py-(e2.from.y+evy*et));
          return dist < e2.lanes*LANE_W/2 + PARKING_RADIUS + 8;
        });
        if(onRoad) continue;

        // æ—¢å­˜ãƒãƒ¼ãƒ‰ï¼ˆå…¨ã‚¿ã‚¤ãƒ—ï¼‰ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯
        const tooClose = nodes.some(n => Math.hypot(n.x-px,n.y-py) < MIN_PARKING_DIST);
        if(tooClose) continue;

        // é…ç½®ç¢ºå®š
        const pNode = new Node(px, py, "parking", true, parkingImg);
        nodes.push(pNode);
        placedParking.push(pNode);

        // æœ€ã‚‚è¿‘ã„å†…éƒ¨äº¤å·®ç‚¹ã¨æ¥ç¶š
        const nearest = nodes
          .filter(n=>n.type==="cross"&&!n.external&&Math.hypot(n.x-px,n.y-py)<350)
          .sort((a,b)=>Math.hypot(a.x-px,a.y-py)-Math.hypot(b.x-px,b.y-py))[0];
        if(nearest && canAdd(pNode, nearest, 40)){
          edges.push(new Edge(pNode, nearest, "branch"));
          edges.push(new Edge(nearest, pNode, "branch"));
        }
        break; // ã“ã®ã‚¨ãƒƒã‚¸ã§ã¯1ã¤é…ç½®ã—ãŸã‚‰æ¬¡ã®ã‚¨ãƒƒã‚¸ã¸
      }
    }
  }

  // ================================================================
  // 4. å¤–éƒ¨ãƒãƒ¼ãƒ‰å­¤ç«‹ãƒã‚§ãƒƒã‚¯
  // ================================================================
  const extNodes=nodes.filter(n=>n.external);
  const intNodes=nodes.filter(n=>n.type==="cross"&&!n.external);
  for(const ext of extNodes){
    const hasOut=edges.some(e=>e.from===ext);
    const hasIn =edges.some(e=>e.to===ext);
    if(!hasOut||!hasIn){
      // è·é›¢é †ã«å€™è£œã‚’è©¦ã—ã€äº¤å·®ã—ãªã„æœ€åˆã®ãƒãƒ¼ãƒ‰ã¸æ¥ç¶š
      const sorted=intNodes.slice()
        .sort((a,b)=>Math.hypot(a.x-ext.x,a.y-ext.y)-Math.hypot(b.x-ext.x,b.y-ext.y));
      for(const nearest of sorted){
        // crossesAnyEdge ã§äº¤å·®ãƒã‚§ãƒƒã‚¯ï¼ˆå¤–éƒ¨ãƒãƒ¼ãƒ‰æ¥ç¶šã¯äº¤å·®è¨±å®¹ã®ãŸã‚ canAddExt ç›¸å½“ï¼‰
        const share=(a,b)=>edges.some(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a));
        if(!hasOut && !share(ext,nearest)){
          // å…±æœ‰ç«¯ç‚¹ä»¥å¤–ã¨ã®äº¤å·®ãŒãªã‘ã‚Œã°è¿½åŠ 
          let ok=true;
          for(const e of edges){
            if(e.from===ext||e.to===ext||e.from===nearest||e.to===nearest) continue;
            if(segmentsCross(ext,nearest,e.from,e.to)){ok=false;break;}
          }
          if(ok) edges.push(new Edge(ext,nearest,"branch"));
        }
        if(!hasIn && !share(nearest,ext)){
          let ok=true;
          for(const e of edges){
            if(e.from===ext||e.to===ext||e.from===nearest||e.to===nearest) continue;
            if(segmentsCross(nearest,ext,e.from,e.to)){ok=false;break;}
          }
          if(ok) edges.push(new Edge(nearest,ext,"branch"));
        }
        if(edges.some(e=>e.from===ext) && edges.some(e=>e.to===ext)) break;
      }
    }
  }

  // ================================================================
  // 4a. ä¿¡å·æ©Ÿã®åˆæœŸé…ç½®ï¼ˆå†…éƒ¨äº¤å·®ç‚¹ã®40%ã®ã¿ä¿¡å·ã‚ã‚Šï¼‰
  // ================================================================
  {
    const intCross = nodes.filter(n => n.type==="cross" && !n.external);
    for(const n of intCross){
      n.hasSignal = Math.random() < 0.40;
    }
  }

  // ================================================================
  // 4b. ç”Ÿæˆå¾Œã‚¯ãƒ­ã‚¹æ¤œè¨¼ â€” å®‰å…¨ç¶²
  // ----------------------------------------------------------------
  // å…¨ã‚¨ãƒƒã‚¸ãƒšã‚¢ã‚’èµ°æŸ»ã—ã¦äº¤å·®ã—ã¦ã„ã‚‹ã‚¨ãƒƒã‚¸ã‚’æ¤œå‡ºãƒ»å‰Šé™¤ã™ã‚‹ã€‚
  // ã©ã®ãƒ‘ã‚¹ï¼ˆsplitEdge / [B] / [D] / å­¤ç«‹è£œå®Œï¼‰ã§è¿½åŠ ã•ã‚ŒãŸã‚¨ãƒƒã‚¸ã§ã‚‚
  // äº¤å·®ãŒæ®‹ã£ã¦ã„ã‚Œã°é™¤å»ã•ã‚Œã‚‹ã€‚
  // å¹¹ç·šåŒå£«ã®ã€Œè¨­è¨ˆä¸Šã®äº¤å·®ç‚¹ã€ã¯å…±æœ‰ãƒãƒ¼ãƒ‰ã§æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ãŸã‚é™¤å¤–ã•ã‚Œã‚‹ã€‚
  {
    let removed;
    let pass = 0;
    do {
      removed = 0;
      pass++;
      // å‰Šé™¤å€™è£œã‚’åé›†ï¼ˆå‰Šé™¤ä¸­ã«é…åˆ—ã‚’å¤‰ãˆãªã„ã‚ˆã†ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼‰
      const snap = [...edges];
      const toDelete = new Set();
      for(let i = 0; i < snap.length; i++){
        if(toDelete.has(snap[i])) continue;
        for(let j = i+1; j < snap.length; j++){
          if(toDelete.has(snap[j])) continue;
          const e1 = snap[i], e2 = snap[j];
          if(!segmentsCross(e1.from,e1.to,e2.from,e2.to)) continue;
          // äº¤å·®ã—ã¦ã„ã‚‹ãƒšã‚¢ã‚’ç™ºè¦‹ â†’ branch/oneway å´ã‚’å‰Šé™¤ï¼ˆå¹¹ç·šã¯æ®‹ã™ï¼‰
          // ä¸¡æ–¹ main ã®å ´åˆã¯å¾Œã‹ã‚‰è¿½åŠ ã•ã‚ŒãŸæ–¹ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå¤§ãã„æ–¹ï¼‰ã‚’å‰Šé™¤
          if(e1.type==="main" && e2.type==="main"){
            toDelete.add(snap[j]); // jå´ã‚’å‰Šé™¤
          } else if(e2.type==="main"){
            toDelete.add(e1); // main ã§ãªã„ e1 ã‚’å‰Šé™¤
          } else {
            toDelete.add(e2); // main ã§ãªã„ e2 ã‚’å‰Šé™¤ï¼ˆã¾ãŸã¯ä¸¡æ–¹ branchâ†’ jå´ï¼‰
          }
        }
      }
      // å‰Šé™¤
      for(const e of toDelete){
        const idx = edges.indexOf(e);
        if(idx !== -1){ edges.splice(idx,1); removed++; }
      }
    } while(removed > 0 && pass < 10); // æœ€å¤§10ãƒ‘ã‚¹ã¾ã§ç¹°ã‚Šè¿”ã™
    if(pass > 1) console.log(`[CrossFix] ${pass}ãƒ‘ã‚¹ã§äº¤å·®ã‚¨ãƒƒã‚¸ã‚’é™¤å»`);
  }

  // ================================================================
  // 5. å·ã®ç”Ÿæˆ
  // ================================================================
  // hYsï¼ˆæ°´å¹³å¹¹ç·šã®yåº§æ¨™ï¼‰ã®éš£æ¥ãƒšã‚¢é–“ã€ãŠã‚ˆã³
  // vXsï¼ˆå‚ç›´å¹¹ç·šã®xåº§æ¨™ï¼‰ã®éš£æ¥ãƒšã‚¢é–“ã‚’èª¿ã¹ã€
  // ã€Œå·ã¨ã—ã¦é©åˆ‡ãªæ¡ä»¶ã€ã‚’æº€ãŸã™å ´åˆã«ç¢ºç‡ã§å·ã‚’ç”Ÿæˆã™ã‚‹ã€‚
  //
  // å·ã¨ã—ã¦é©åˆ‡ãªæ¡ä»¶:
  //  â‘  2æœ¬ã®å¹³è¡Œå¹¹ç·šã®é–“éš”ãŒ 80ã€œ280pxï¼ˆåºƒã™ããšç‹­ã™ããšï¼‰
  //  â‘¡ ãã®å¸¯çŠ¶é ˜åŸŸã®å†…éƒ¨ã«äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ãªã„
  //     ï¼ˆé“è·¯ãŒé€šã£ã¦ã„ãªã„ç©ºç™½åœ°å¸¯ï¼‰
  //  â‘¢ ç¢ºç‡ 60% ã§å‡ºç¾

  rivers.length = 0; // ãƒªã‚»ãƒƒãƒˆ

  const ROAD_HALF = 20; // é“è·¯ç«¯ã‹ã‚‰ã®ä½™ç™½ï¼ˆå·ã¯é“è·¯ã«è¢«ã‚‰ãªã„ï¼‰
  const RIVER_MIN = 80, RIVER_MAX = 280;

  // æ°´å¹³å¹¹ç·šãƒšã‚¢ â†’ æ¨ªå‘ãå·
  for(let i=0; i<hYs.length-1; i++){
    const y1 = hYs[i]   + ROAD_HALF;
    const y2 = hYs[i+1] - ROAD_HALF;
    const gap = y2 - y1;
    if(gap < RIVER_MIN || gap > RIVER_MAX) continue;
    // å¸¯ã®å†…éƒ¨ã«äº¤å·®ç‚¹ãŒå…¥ã‚Šè¾¼ã‚“ã§ã„ãªã„ã‹
    const blocked = nodes.some(n =>
      n.type === "cross" && !n.external &&
      n.y > hYs[i] + ROAD_HALF && n.y < hYs[i+1] - ROAD_HALF
    );
    if(blocked) continue;
    if(Math.random() < 0.85){
      rivers.push({ type:"h", y1, y2 });
    }
  }

  // å‚ç›´å¹¹ç·šãƒšã‚¢ â†’ ç¸¦å‘ãå·
  for(let i=0; i<vXs.length-1; i++){
    const x1 = vXs[i]   + ROAD_HALF;
    const x2 = vXs[i+1] - ROAD_HALF;
    const gap = x2 - x1;
    if(gap < RIVER_MIN || gap > RIVER_MAX) continue;
    const blocked = nodes.some(n =>
      n.type === "cross" && !n.external &&
      n.x > vXs[i] + ROAD_HALF && n.x < vXs[i+1] - ROAD_HALF
    );
    if(blocked) continue;
    if(Math.random() < 0.85){
      rivers.push({ type:"v", x1, x2 });
    }
  }

  // ================================================================
  // 6. åœ°å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆï¼ˆsinåˆæˆãƒã‚¤ã‚º + ã‚¿ã‚¤ãƒ«ç”»åƒï¼‰
  // ================================================================
  // sinåˆæˆãƒã‚¤ã‚ºã§ã‚»ãƒ«ã”ã¨ã«åœ°å½¢ã‚¿ã‚¤ãƒ—ã‚’æ±ºå®šã—ã€
  // ground_1(è‰åœ°) / ground_2(ç ‚åœ°) / ground_3(åœŸ) ã®128Ã—128pxã‚¿ã‚¤ãƒ«ã‚’è²¼ã‚‹ã€‚
  // ç”»åƒæœªãƒ­ãƒ¼ãƒ‰æ™‚ã¯å¾“æ¥ã®è‰²å¡—ã‚Šã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‚
  // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³Canvasã«ä¸€æ‹¬æç”»ã—ã€æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ drawImage 1å›ã®ã¿ã€‚
  {
    const W = 1000, H = 700;
    const TILE = 128; // ã‚¿ã‚¤ãƒ«1æšã®ã‚µã‚¤ã‚º
    terrainCanvas = document.createElement("canvas");
    terrainCanvas.width  = W;
    terrainCanvas.height = H;
    const tCtx = terrainCanvas.getContext("2d");

    // ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰å€¤ï¼ˆãƒªãƒ­ãƒ¼ãƒ‰ã”ã¨ã«ç•°ãªã‚‹åœ°å½¢ï¼‰
    const sx = Math.random() * 500;
    const sy = Math.random() * 500;

    // sinåˆæˆãƒã‚¤ã‚ºï¼ˆ5ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ï¼‰â†’ 0ã€œ1
    function noiseVal(x, y){
      const x0 = x + sx, y0 = y + sy;
      let v = 0;
      v += Math.sin(x0 * 0.008 + y0 * 0.005) * 0.40;
      v += Math.sin(x0 * 0.022 + y0 * 0.019 + 1.3) * 0.25;
      v += Math.sin(x0 * 0.055 + y0 * 0.048 + 2.7) * 0.15;
      v += Math.sin((x0 + y0) * 0.015 + 0.8) * 0.12;
      v += Math.sin(x0 * 0.11  + y0 * 0.09  + 4.1) * 0.08;
      return (v + 1) * 0.5; // 0ã€œ1
    }

    // ãƒã‚¤ã‚ºå€¤ â†’ åœ°å½¢ã‚¿ã‚¤ãƒ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    // 0: è‰åœ°(ground_1)  1: ç ‚åœ°(ground_2)  2: åœŸ(ground_3)
    // è‡ªç„¶ãªåœ°å½¢ã‚‰ã—ã: è‰åœ°ãŒå¤šã‚ã€ç ‚åœ°ãƒ»åœŸãŒç‚¹åœ¨
    function tileIndex(t){
      if(t < 0.30) return 2; // åœŸ     (0ã€œ0.30)
      if(t < 0.55) return 1; // ç ‚åœ°   (0.30ã€œ0.55)
      return 0;              // è‰åœ°   (0.55ã€œ1.0)
    }

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã‚«ãƒ©ãƒ¼ï¼ˆåœ°å½¢ã‚¿ã‚¤ãƒ—åˆ¥ï¼‰
    const fallbackColors = [
      [75, 120, 65],   // è‰åœ°: ç·‘
      [145, 120, 75],  // ç ‚åœ°: é»„è¤è‰²
      [110, 85, 60],   // åœŸ: èŒ¶è‰²
    ];

    // ç”»åƒãŒå…¨ã¦èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    const tilesReady = groundImgs.every(img => img.complete && img.naturalWidth > 0);

    if(tilesReady){
      // ===== ã‚¿ã‚¤ãƒ«ç”»åƒãƒ¢ãƒ¼ãƒ‰ =====
      // ã‚»ãƒ«ã”ã¨ã«ãƒã‚¤ã‚ºå€¤ã‚’è¨ˆç®—ã—ã¦ã‚¿ã‚¤ãƒ«ã‚’é¸æŠã—è²¼ã‚Šä»˜ã‘ã‚‹
      // ã‚»ãƒ«ä¸­å¿ƒåº§æ¨™ã§ãƒã‚¤ã‚ºã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆã‚¿ã‚¤ãƒ«å¢ƒç•Œã®ãƒ ãƒ©ã‚’é˜²ãï¼‰
      for(let cy = 0; cy < H; cy += TILE){
        for(let cx = 0; cx < W; cx += TILE){
          // ã‚»ãƒ«ä¸­å¿ƒã§ãƒã‚¤ã‚ºã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
          const t = noiseVal(cx + TILE/2, cy + TILE/2);
          const idx = tileIndex(t);
          const img = groundImgs[idx];
          // ã‚»ãƒ«ãŒç”»é¢ç«¯ã§128pxæœªæº€ã«ãªã‚‹å ´åˆã‚‚å¯¾å¿œï¼ˆclipã§è¶…ééƒ¨åˆ†ã‚’åˆ‡ã‚‹ï¼‰
          tCtx.save();
          tCtx.beginPath();
          tCtx.rect(cx, cy, Math.min(TILE, W-cx), Math.min(TILE, H-cy));
          tCtx.clip();
          tCtx.drawImage(img, cx, cy, TILE, TILE);
          tCtx.restore();
        }
      }

      // ã‚¿ã‚¤ãƒ«å¢ƒç•Œã‚’è‡ªç„¶ã«è¦‹ã›ã‚‹ãŸã‚ã€å¢ƒç•Œä»˜è¿‘ã«ã‚½ãƒ•ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’æ–½ã™
      // éš£æ¥ã‚»ãƒ«ã®åœ°å½¢ã‚¿ã‚¤ãƒ—ãŒç•°ãªã‚‹å¢ƒç•Œã«ã®ã¿ã€ç´°ã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¸¯ã‚’æã
      tCtx.globalAlpha = 0.35;
      for(let cy = 0; cy < H; cy += TILE){
        for(let cx = 0; cx < W; cx += TILE){
          const t  = noiseVal(cx + TILE/2, cy + TILE/2);
          const tR = noiseVal(cx + TILE*1.5, cy + TILE/2);
          const tB = noiseVal(cx + TILE/2, cy + TILE*1.5);
          const idxC = tileIndex(t);
          // å³éš£ã¨ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ãªã‚‰å³ç«¯ã«ãƒ–ãƒ¬ãƒ³ãƒ‰å¸¯
          if(cx + TILE < W && tileIndex(tR) !== idxC){
            const g = tCtx.createLinearGradient(cx+TILE-16, 0, cx+TILE+16, 0);
            const [r1,g1,b1] = fallbackColors[idxC];
            const [r2,g2,b2] = fallbackColors[tileIndex(tR)];
            g.addColorStop(0, `rgba(${r1},${g1},${b1},0)`);
            g.addColorStop(0.5, `rgba(${Math.round((r1+r2)/2)},${Math.round((g1+g2)/2)},${Math.round((b1+b2)/2)},0.6)`);
            g.addColorStop(1, `rgba(${r2},${g2},${b2},0)`);
            tCtx.fillStyle = g;
            tCtx.fillRect(cx+TILE-16, cy, 32, TILE);
          }
          // ä¸‹éš£ã¨ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ãªã‚‰ä¸‹ç«¯ã«ãƒ–ãƒ¬ãƒ³ãƒ‰å¸¯
          if(cy + TILE < H && tileIndex(tB) !== idxC){
            const g = tCtx.createLinearGradient(0, cy+TILE-16, 0, cy+TILE+16);
            const [r1,g1,b1] = fallbackColors[idxC];
            const [r2,g2,b2] = fallbackColors[tileIndex(tB)];
            g.addColorStop(0, `rgba(${r1},${g1},${b1},0)`);
            g.addColorStop(0.5, `rgba(${Math.round((r1+r2)/2)},${Math.round((g1+g2)/2)},${Math.round((b1+b2)/2)},0.6)`);
            g.addColorStop(1, `rgba(${r2},${g2},${b2},0)`);
            tCtx.fillStyle = g;
            tCtx.fillRect(cx, cy+TILE-16, TILE, 32);
          }
        }
      }
      tCtx.globalAlpha = 1.0;

    } else {
      // ===== ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®è‰²å¡—ã‚Šãƒ¢ãƒ¼ãƒ‰ =====
      const imageData = tCtx.createImageData(W, H);
      const data = imageData.data;
      for(let y = 0; y < H; y++){
        for(let x = 0; x < W; x++){
          const t = noiseVal(x, y);
          const [r, g, b] = fallbackColors[tileIndex(t)];
          const i = (y * W + x) * 4;
          data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=255;
        }
      }
      tCtx.putImageData(imageData, 0, 0);
    }
  }
}


// ===== ã‚¹ã‚³ã‚¢æ›´æ–° =====
function updateScore(jamCount){
  // æ¸‹æ»ã‚¼ãƒ­ãªã‚‰é€£ç¶šãƒœãƒ¼ãƒŠã‚¹è“„ç©ã€æ¸‹æ»ãŒã‚ã‚Œã°ãƒªã‚»ãƒƒãƒˆ
  if(jamCount === 0){
    bonusStreak++;
    // 60ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„1ç§’ï¼‰ã”ã¨ã«ãƒœãƒ¼ãƒŠã‚¹å€ç‡UPï¼ˆæœ€å¤§8.0ï¼‰
    if(bonusStreak % 60 === 0) scoreBonus = Math.min(8.0, scoreBonus + 0.2);
  } else {
    bonusStreak = 0;
    scoreBonus  = Math.max(1.0, scoreBonus - 0.02);
    // æ¸‹æ»ä¸­ãƒšãƒŠãƒ«ãƒ†ã‚£: æ¸‹æ»1å°ã«ã¤ãæ¯ãƒ•ãƒ¬ãƒ¼ãƒ -0.2ç‚¹
    score = Math.max(0, score - jamCount * 0.2);
  }
  // äº‹æ•…ä¸­ã¯è¿½åŠ ãƒšãƒŠãƒ«ãƒ†ã‚£
  if(accidents.length > 0){
    score = Math.max(0, score - accidents.length * 1);
  }
  // ãƒ©ãƒ³ã‚¯åˆ¤å®š
  let rank="D", cls="rank-D";
  if(score>80000){rank="S";cls="rank-S";}
  else if(score>35000){rank="A";cls="rank-A";}
  else if(score>12000){rank="B";cls="rank-B";}
  else if(score>3000) {rank="C";cls="rank-C";}
  const rv=document.getElementById("rankVal");
  rv.textContent=rank; rv.className=cls;
  budget = score; // äºˆç®—ã¯ã‚¹ã‚³ã‚¢ã¨åŒå€¤
  document.getElementById("scoreVal").textContent=Math.floor(score).toLocaleString();
  document.getElementById("budgetVal").textContent=Math.floor(budget).toLocaleString()+'pt';
  document.getElementById("bonusVal").textContent=`BONUS Ã—${scoreBonus.toFixed(1)}`;
  document.getElementById("accVal").textContent=accidentCount;
}

// ===== äº‹æ•…ç™ºç”Ÿ =====
function triggerAccident(){
  // èµ°è¡Œä¸­ã®è»ŠãŒã‚ã‚‹ã‚¨ãƒƒã‚¸ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
  const activeEdges=edges.filter(e=>e.laneCars.some(lc=>lc.length>0));
  if(activeEdges.length===0) return;
  const e=activeEdges[Math.floor(Math.random()*activeEdges.length)];
  const t=0.3+Math.random()*0.4;
  const ax=e.from.x+(e.to.x-e.from.x)*t;
  const ay=e.from.y+(e.to.y-e.from.y)*t;
  // åŒã˜å ´æ‰€ã«é‡è¤‡ã—ãªã„ã‚ˆã†ã«ãƒã‚§ãƒƒã‚¯
  if(accidents.some(a=>Math.hypot(a.x-ax,a.y-ay)<60)) return;
  const acc = {x:ax,y:ay,edge:e,timer:ACCIDENT_DURATION,maxTimer:ACCIDENT_DURATION,blink:0,policeArrived:false};
  accidents.push(acc);
  accidentCount++;
  score=Math.max(0,score-500);

  // ãƒ‘ãƒˆã‚«ãƒ¼ã‚’äº‹æ•…ç¾å ´ã¸æ´¾é£
  dispatchPolice(acc);
}

// ===== ãƒ‘ãƒˆã‚«ãƒ¼æ´¾é£ =====
function dispatchPolice(acc){
  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ã®ä¸­ã§ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‹ã‚‚ã®ã‹ã‚‰æ´¾é£
  const extNodes = nodes.filter(n => n.external && n.type === "cross");
  if(extNodes.length === 0) return;

  // äº‹æ•…ã«æœ€ã‚‚è¿‘ã„ cross ãƒãƒ¼ãƒ‰ã‚’ç›®çš„åœ°ã«ã™ã‚‹
  const intNodes = nodes.filter(n => n.type==="cross" && !n.external);
  if(intNodes.length === 0) return;
  const dest = intNodes.sort((a,b) =>
    Math.hypot(a.x-acc.x,a.y-acc.y) - Math.hypot(b.x-acc.x,b.y-acc.y)
  )[0];

  // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ãŸå¤–éƒ¨ãƒãƒ¼ãƒ‰ã‹ã‚‰BFSã§ãƒ«ãƒ¼ãƒˆã‚’æ¢ã™
  const shuffled = [...extNodes].sort(() => Math.random()-0.5);
  for(const start of shuffled){
    const route = generateRouteBFS(start, [dest]);
    if(route && route.length > 0){
      const policeCar = new Car(route, policeImg);
      policeCar.isPolice = true;
      policeCar.targetAcc = acc;
      policeCar.maxSpeed = 2.5; // ãƒ‘ãƒˆã‚«ãƒ¼ã¯å°‘ã—é€Ÿã„
      cars.push(policeCar);
      policeCars.push({car: policeCar, acc});
      return;
    }
  }
}

// ===== äº‹æ•…æ›´æ–° =====
function updateAccidents(){
  for(let i=accidents.length-1;i>=0;i--){
    const a=accidents[i];
    a.timer--;
    a.blink++;
    if(a.timer<=0){
      accidents.splice(i,1);
      // å¯¾å¿œã™ã‚‹ãƒ‘ãƒˆã‚«ãƒ¼ã‚’æ¶ˆã™ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè§£æ¶ˆï¼‰
      for(const pc of policeCars){
        if(pc.acc===a) pc.car.alive=false;
      }
    }
  }
  // æ­»äº¡ãƒ‘ãƒˆã‚«ãƒ¼ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰é™¤å»
  for(let i=policeCars.length-1;i>=0;i--){
    if(!policeCars[i].car.alive) policeCars.splice(i,1);
  }
}

// ===== äº‹æ•…æç”» =====
function drawAccidents(){
  for(const a of accidents){
    const progress=a.timer/a.maxTimer; // 1.0â†’0.0
    // æ®‹ã‚Šæ™‚é–“ãŒå°‘ãªã„ã»ã©ç‚¹æ»…é€Ÿåº¦UP
    const blinkRate=Math.max(4,Math.floor(progress*20));
    const visible=(Math.floor(a.blink/blinkRate)%2===0);
    if(!visible) continue;

    ctx.save();
    ctx.translate(a.x,a.y);

    // äº‹æ•…ã®å½±éŸ¿åœã‚’åŠé€æ˜èµ¤ã§è¡¨ç¤º
    const alpha=0.15+0.15*Math.sin(a.blink*0.1);
    ctx.beginPath();
    ctx.arc(0,0,ACCIDENT_SLOWZONE,0,Math.PI*2);
    ctx.fillStyle=`rgba(255,60,0,${alpha})`;
    ctx.fill();

    // äº‹æ•…ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç‚+è­¦å‘Šï¼‰
    const sz=22+Math.sin(a.blink*0.15)*3; // è„ˆå‹•
    ctx.font=`${sz}px serif`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText("ğŸ’¥",0,0);
    // ãƒ‘ãƒˆã‚«ãƒ¼åˆ°ç€æ¸ˆã¿è¡¨ç¤º
    if(a.policeArrived){
      ctx.font="14px serif";
      ctx.fillText("ğŸš”",-18,-18);
    }

    // æ®‹ã‚Šæ™‚é–“ãƒãƒ¼
    const barW=40, barH=5;
    ctx.fillStyle="rgba(0,0,0,0.6)";
    ctx.fillRect(-barW/2,14,barW,barH);
    ctx.fillStyle=progress>0.5?"#f0a000":"#ff3030";
    ctx.fillRect(-barW/2,14,barW*progress,barH);

    ctx.restore();
  }
}

// ===== ç·Šæ€¥å¯¾å¿œï¼ˆã‚¯ãƒªãƒƒã‚¯ã§äº‹æ•…ã‚’å³æ™‚è§£æ¶ˆï¼‰=====
function clearAccident(){
  if(accidents.length===0){ alert("ç¾åœ¨ã€äº‹æ•…ã¯ç™ºç”Ÿã—ã¦ã„ã¾ã›ã‚“ã€‚"); return; }
  if(score<300){ alert("ã‚¹ã‚³ã‚¢ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆ300ç‚¹å¿…è¦ï¼‰ã€‚"); return; }
  score-=300;
  const removed=accidents.splice(0,1)[0];
  // å¯¾å¿œãƒ‘ãƒˆã‚«ãƒ¼ã‚‚æ¶ˆã™
  if(removed){
    for(const pc of policeCars){
      if(pc.acc===removed) pc.car.alive=false;
    }
  }
}

// ===== Canvas ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ© =====
canvas.addEventListener("click", ev=>{
  const r=canvas.getBoundingClientRect();
  const mx=ev.clientX-r.left, my=ev.clientY-r.top;

  // --- ä¿¡å·è¨­ç½®/æ’¤å»ãƒ¢ãƒ¼ãƒ‰: äº¤å·®ç‚¹ã‚¯ãƒªãƒƒã‚¯ ---
  if(operationMode==='install' || operationMode==='remove'){
    const node = nodes.find(n =>
      n.type==="cross" && !n.external &&
      Math.abs(n.x-mx)<20 && Math.abs(n.y-my)<20
    );
    if(node){
      if(operationMode==='install'){
        if(node.hasSignal){ showToast('æ—¢ã«ä¿¡å·ãŒã‚ã‚Šã¾ã™'); return; }
        if(budget < COST_INSTALL){ flashBudget(); return; }
        node.hasSignal=true;
        budget-=COST_INSTALL; score-=COST_INSTALL;
        showToast('ğŸš¦ ä¿¡å·ã‚’è¨­ç½®ã—ã¾ã—ãŸ (-'+COST_INSTALL+'pt)');
      } else {
        if(!node.hasSignal){ showToast('ä¿¡å·ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
        if(budget < COST_REMOVE){ flashBudget(); return; }
        node.hasSignal=false;
        budget-=COST_REMOVE; score-=COST_REMOVE;
        showToast('ğŸ—‘ ä¿¡å·ã‚’æ’¤å»ã—ã¾ã—ãŸ (-'+COST_REMOVE+'pt)');
      }
      updateBudgetButtons();
    }
    return;
  }

  // --- ä¸€æ–¹é€šè¡Œåè»¢ãƒ¢ãƒ¼ãƒ‰: ã‚¨ãƒƒã‚¸ã‚¯ãƒªãƒƒã‚¯ ---
  if(operationMode==='reverse'){
    let bestEdge=null, bestDist=18;
    for(const e of edges){
      if(e.type!=='oneway') continue;
      const ex=e.to.x-e.from.x, ey=e.to.y-e.from.y, el=Math.hypot(ex,ey);
      if(el<1) continue;
      const t=Math.max(0,Math.min(1,((mx-e.from.x)*ex+(my-e.from.y)*ey)/(el*el)));
      const dist=Math.hypot(mx-(e.from.x+ex*t), my-(e.from.y+ey*t));
      if(dist<bestDist){ bestDist=dist; bestEdge=e; }
    }
    if(bestEdge){
      if(reverseHighlight===bestEdge){
        reverseOneway(bestEdge);
      } else {
        reverseHighlight=bestEdge;
        showToast('ã‚‚ã†ä¸€åº¦ã‚¯ãƒªãƒƒã‚¯ã§åè»¢ç¢ºå®š (-'+COST_REVERSE+'pt)');
      }
    }
    return;
  }

  // --- é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ ---
  // äº‹æ•…ã‚¢ã‚¤ã‚³ãƒ³ã‚¯ãƒªãƒƒã‚¯
  for(let i=accidents.length-1;i>=0;i--){
    const a=accidents[i];
    if(Math.hypot(mx-a.x,my-a.y)<30){
      if(score>=300){
        score-=300; budget-=300;
        accidents.splice(i,1);
        for(const pc of policeCars){ if(pc.acc===a) pc.car.alive=false; }
        document.getElementById("scoreVal").textContent=Math.floor(score).toLocaleString();
        showToast('ğŸš¨ äº‹æ•…ã‚’å‡¦ç†ã—ã¾ã—ãŸ');
      } else { flashBudget(); }
      return;
    }
  }

  // äº¤å·®ç‚¹ã‚¯ãƒªãƒƒã‚¯ï¼ˆä¿¡å·ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®šï¼‰
  selectedNode=null;
  for(const n of nodes){
    if(n.type!=="cross"||n.external) continue;
    if(Math.abs(n.x-mx)<15&&Math.abs(n.y-my)<15){
      selectedNode=n;
      if(n.hasSignal){
        document.getElementById("greenSlider").value=n.greenDuration;
        document.getElementById("greenVal").textContent=n.greenDuration;
      }
      break;
    }
  }
});

// ä¸€æ–¹é€šè¡Œãƒã‚¤ãƒ©ã‚¤ãƒˆæç”»
function drawReverseHighlight(){
  if(!reverseHighlight) return;
  const e=reverseHighlight;
  const dx=e.to.x-e.from.x, dy=e.to.y-e.from.y;
  const angle=Math.atan2(dy,dx);
  const dist=Math.hypot(dx,dy);
  ctx.save();
  ctx.translate(e.from.x,e.from.y);
  ctx.rotate(angle);
  ctx.strokeStyle='rgba(255,220,0,0.85)';
  ctx.lineWidth=4;
  ctx.setLineDash([8,4]);
  ctx.strokeRect(0,-e.lanes*LANE_W,dist,e.lanes*LANE_W);
  ctx.setLineDash([]);
  ctx.fillStyle='rgba(255,220,0,0.9)';
  ctx.font='bold 14px sans-serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  const step=70;
  for(let x=step/2;x<dist;x+=step) ctx.fillText('â—€',x,-e.lanes*LANE_W/2);
  ctx.restore();
}
// ===== äºˆç®—ãƒ»æ“ä½œã‚·ã‚¹ãƒ†ãƒ  =====
const COST_INSTALL = 500;
const COST_REMOVE  = 300;
const COST_REVERSE = 800;

function setMode(mode){
  operationMode = mode;
  reverseHighlight = null;
  const labels = {
    install: 'ğŸ“ ä¿¡å·è¨­ç½®ãƒ¢ãƒ¼ãƒ‰ï¼ˆäº¤å·®ç‚¹ã‚¯ãƒªãƒƒã‚¯ï¼‰',
    remove:  'ğŸ—‘ ä¿¡å·æ’¤å»ãƒ¢ãƒ¼ãƒ‰ï¼ˆäº¤å·®ç‚¹ã‚¯ãƒªãƒƒã‚¯ï¼‰',
    reverse: 'ğŸ”€ ä¸€æ–¹é€šè¡Œåè»¢ãƒ¢ãƒ¼ãƒ‰ï¼ˆé“è·¯ã‚¯ãƒªãƒƒã‚¯ï¼‰',
  };
  document.getElementById('modeLabel').textContent =
    mode ? labels[mode] : 'ãƒ¢ãƒ¼ãƒ‰: é€šå¸¸';
  // ãƒœã‚¿ãƒ³ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  ['btnInstall','btnRemove','btnReverse'].forEach(id=>{
    document.getElementById(id).classList.remove('btn-active');
  });
  if(mode==='install') document.getElementById('btnInstall').classList.add('btn-active');
  if(mode==='remove')  document.getElementById('btnRemove').classList.add('btn-active');
  if(mode==='reverse') document.getElementById('btnReverse').classList.add('btn-active');
  updateBudgetButtons();
}

function updateBudgetButtons(){
  document.getElementById('btnInstall').disabled = budget < COST_INSTALL;
  document.getElementById('btnRemove').disabled  = budget < COST_REMOVE;
  document.getElementById('btnReverse').disabled = budget < COST_REVERSE;
}

function flashBudget(){
  const el = document.getElementById('budgetVal');
  el.style.color='#ff4040';
  setTimeout(()=>el.style.color='#f0c040', 500);
}

// ä¸€æ–¹é€šè¡Œåè»¢: fromâ†”to ã‚’å…¥ã‚Œæ›¿ãˆã€èµ°è¡Œä¸­ã®è»Šã‚’é™¤å»
function reverseOneway(edge){
  if(budget < COST_REVERSE){ flashBudget(); return; }
  // ãã®ã‚¨ãƒƒã‚¸ä¸Šã®è»Šã‚’å…¨ã¦æ¶ˆã™
  for(let i=cars.length-1;i>=0;i--){
    if(cars[i].edge===edge) cars[i].alive=false;
  }
  // from/to ã‚’å…¥ã‚Œæ›¿ãˆ
  const tmp=edge.from; edge.from=edge.to; edge.to=tmp;
  // laneCars ãƒªã‚»ãƒƒãƒˆ
  edge.laneCars = Array.from({length:edge.lanes}, ()=>[]);
  edge.length = Math.hypot(edge.to.x-edge.from.x, edge.to.y-edge.from.y);
  budget -= COST_REVERSE;
  score  -= COST_REVERSE;
  reverseHighlight = null;
  setMode(null);
  showToast('ğŸ”€ ä¸€æ–¹é€šè¡Œã‚’åè»¢ã—ã¾ã—ãŸ');
}

// ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥
function showToast(msg){
  let el=document.getElementById('toast');
  if(!el){
    el=document.createElement('div');
    el.id='toast';
    el.style.cssText='position:fixed;bottom:30px;left:50%;transform:translateX(-50%);'
      +'background:rgba(0,0,0,0.8);color:white;padding:8px 18px;border-radius:20px;'
      +'font-size:14px;pointer-events:none;z-index:9999;transition:opacity 0.4s';
    document.body.appendChild(el);
  }
  el.textContent=msg; el.style.opacity='1';
  clearTimeout(el._tid);
  el._tid=setTimeout(()=>el.style.opacity='0', 2000);
}

// ===== BFSãƒ«ãƒ¼ãƒˆç”Ÿæˆï¼ˆè»Šç·šãƒ«ãƒ¼ãƒ«å¯¾å¿œç‰ˆï¼‰=====
// targetNodes: åˆ°é”ç›®æ¨™ãƒãƒ¼ãƒ‰ã®é…åˆ—ï¼ˆå‘¼ã³å‡ºã—å´ã§æŒ‡å®šï¼‰
function generateRouteBFS(startNode, targetNodes){
  const targets = targetNodes.filter(n => n !== startNode);
  if(targets.length === 0) return null;

  const queue = [{ node: startNode, path: [], prevEdge: null }];
  const visited = new Set([startNode]);

  while (queue.length > 0) {
    const { node, path, prevEdge } = queue.shift();
    if (targets.includes(node) && path.length > 0) return path;

    for (const e of edges) {
      if (e.from !== node || visited.has(e.to)) continue;
      visited.add(e.to);
      // äº¤å·®ç‚¹ã§ã®é€²è¡Œæ–¹å‘ã«å¿œã˜ãŸåˆæœŸè»Šç·šã‚’æ±ºå®š
      const lane = selectLaneForTurn(e, prevEdge);
      queue.push({ node: e.to, path: [...path, { edge: e, lane }], prevEdge: e });
    }
  }
  return null;
}

// ===== é€²è¡Œæ–¹å‘ã«å¿œã˜ãŸè»Šç·šé¸æŠ =====
// å·¦å´é€šè¡Œãƒ«ãƒ¼ãƒ«:
//   lane0 = ä¸­å¤®å¯„ã‚Šï¼ˆå†…å´ï¼‰: ç›´é€²ãƒ»å³æŠ˜
//   lane1 = å¤–å´: å·¦æŠ˜
// prevEdge: ç›´å‰ã«èµ°ã£ãŸã‚¨ãƒƒã‚¸ï¼ˆäº¤å·®ç‚¹ã«å…¥ã‚‹æ–¹å‘ï¼‰
// curEdge:  ã“ã‚Œã‹ã‚‰èµ°ã‚‹ã‚¨ãƒƒã‚¸ï¼ˆäº¤å·®ç‚¹ã‚’å‡ºã‚‹æ–¹å‘ï¼‰
function selectLaneForTurn(curEdge, prevEdge){
  if(curEdge.lanes === 1) return 0; // 1è»Šç·šã¯é¸æŠã®ä½™åœ°ãªã—
  if(!prevEdge) return 0;            // æœ€åˆã®ã‚¨ãƒƒã‚¸: å†…å´

  // é€²è¡Œæ–¹å‘ã®å¤‰åŒ–è§’ã‚’è¨ˆç®—ï¼ˆ-Ï€ã€œÏ€ï¼‰
  const inDx  = prevEdge.to.x - prevEdge.from.x;
  const inDy  = prevEdge.to.y - prevEdge.from.y;
  const outDx = curEdge.to.x  - curEdge.from.x;
  const outDy = curEdge.to.y  - curEdge.from.y;

  // å¤–ç©ï¼ˆcross productï¼‰: æ­£=å·¦æŠ˜, è² =å³æŠ˜, 0=ç›´é€²
  const cross = inDx * outDy - inDy * outDx;
  const dot   = inDx * outDx + inDy * outDy;
  const angle = Math.atan2(cross, dot); // -Ï€ã€œÏ€

  if(angle > Math.PI / 6){
    // å·¦æŠ˜ï¼ˆangle > 30åº¦ï¼‰â†’ å¤–å´è»Šç·š lane1
    return 1;
  } else {
    // ç›´é€²ãƒ»å³æŠ˜ â†’ å†…å´è»Šç·š lane0
    return 0;
  }
}

// ===== è»Šç·šé¸æŠï¼ˆæ··é›‘å›é¿ï¼‰=====
function selectLane(edge){
  let min = Infinity, chosen = 0;
  for (let i = 0; i < edge.lanes; i++) {
    if (edge.laneCars[i].length < min) { min = edge.laneCars[i].length; chosen = i; }
  }
  return chosen;
}

// æ”¯ç·šæœ«ç«¯ãƒãƒ¼ãƒ‰: å…¨æ¥ç¶šã‚¨ãƒƒã‚¸ãŒbranchã®ã¿ã®ãƒãƒ¼ãƒ‰ï¼ˆç´”ç²‹ãªæã®å…ˆç«¯ï¼‰
function getBranchTerminals(){
  return nodes.filter(n => {
    if(n.external || n.type !== "cross") return false;
    const conn = edges.filter(e => e.from === n || e.to === n);
    return conn.length > 0 && conn.every(e => e.type === "branch" || e.type === "oneway");
  });
}

// ===== è»Šç”Ÿæˆ =====
function spawnCar(){
  // ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹: å¤–éƒ¨ãƒãƒ¼ãƒ‰ + é§è»Šå ´ãƒãƒ¼ãƒ‰
  const spawnNodes = nodes.filter(n => n.external); // parking(external=true) ã‚‚å«ã‚€
  if(spawnNodes.length === 0) return;
  const start = spawnNodes[Math.floor(Math.random() * spawnNodes.length)];
  const img = carImgs[Math.floor(Math.random() * carImgs.length)];

  // ç›®çš„åœ°ã®å„ªå…ˆåº¦:
  //  30%: é§è»Šå ´ã‚’ç›®çš„åœ°ã«
  //  20%: ä¼šç¤¾ã‚’ç›®çš„åœ°ã«
  //  20%: æ”¯ç·šæœ«ç«¯ã‚’ç›®çš„åœ°ã«
  //  30%: å¤–éƒ¨ãƒãƒ¼ãƒ‰â†’å¤–éƒ¨ãƒãƒ¼ãƒ‰ï¼ˆé€šå¸¸ï¼‰
  const rand = Math.random();

  if(rand < 0.30){
    // é§è»Šå ´ã‚’ç›®çš„åœ°ã«
    const parkings = nodes.filter(n => n.type==="parking" && n !== start);
    if(parkings.length > 0){
      const shuffled = [...parkings].sort(() => Math.random() - 0.5);
      for(const goal of shuffled){
        const route = generateRouteBFS(start, [goal]);
        if(route && route.length > 0){
          cars.push(new Car(route, img));
          return;
        }
      }
    }
  } else if(rand < 0.50){
    // ä¼šç¤¾ã‚’ç›®çš„åœ°ã«ï¼ˆBFSã§ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Œã°ï¼‰
    const companies = nodes.filter(n => n.type==="company" && n !== start);
    if(companies.length > 0){
      const shuffled = [...companies].sort(() => Math.random() - 0.5);
      for(const goal of shuffled){
        // company ã¯ cross ã§ãªã„ã®ã§ BFS ã®çµ‚ç‚¹ã¨ã—ã¦ç›´æ¥ä½¿ãˆãªã„
        // â†’ company ã«æœ€ã‚‚è¿‘ã„ cross ãƒãƒ¼ãƒ‰ã‚’çµ‚ç‚¹ã«ã™ã‚‹
        const nearest = nodes.filter(n=>n.type==="cross"&&!n.external)
          .sort((a,b)=>Math.hypot(a.x-goal.x,a.y-goal.y)-Math.hypot(b.x-goal.x,b.y-goal.y))[0];
        if(!nearest) continue;
        const route = generateRouteBFS(start, [nearest]);
        if(route && route.length > 0){
          cars.push(new Car(route, img));
          return;
        }
      }
    }
  } else if(rand < 0.70){
    // æ”¯ç·šæœ«ç«¯ã‚’ç›®çš„åœ°ã«
    const terminals = getBranchTerminals();
    if(terminals.length > 0){
      const shuffled = [...terminals].sort(() => Math.random() - 0.5);
      for(const goal of shuffled){
        const route = generateRouteBFS(start, [goal]);
        if(route && route.length > 0){
          cars.push(new Car(route, img));
          return;
        }
      }
    }
  }

  // é€šå¸¸: å¤–éƒ¨ãƒãƒ¼ãƒ‰â†’å¤–éƒ¨ãƒãƒ¼ãƒ‰ï¼ˆé§è»Šå ´ä»¥å¤–ï¼‰
  const extOnly = nodes.filter(n => n.external && n.type !== "parking" && n !== start);
  const route = generateRouteBFS(start, extOnly.length>0 ? extOnly : spawnNodes);
  if(!route || route.length === 0) return;
  cars.push(new Car(route, img));
}

// ===== æ™‚é–“æ›´æ–° =====
function updateTime(){
  timeCounter++;
  const t=timeCounter%3600;
  let rate=0.02;
  if(t<800||(t>1800&&t<2600)) rate=0.08;
  else if(t>3000) rate=0.01;
  if(Math.random()<rate*flowRate*2) spawnCar();
  document.getElementById("timeLabel").textContent=
    (t<800||(t>1800&&t<2600))?"Rush":(t>3000?"Night":"Day");
}

// ===== é“è·¯æç”» =====
//
// æç”»æ–¹é‡:
//   â‘  drawIntersectionPads(): äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰ã« kousaten.png ã‚’æãï¼ˆæœ€åˆï¼‰
//   â‘¡ drawRoad(e): å„ã‚¨ãƒƒã‚¸ã‚’æãã€‚äº¤å·®ç‚¹ç«¯ã¯ãƒ‘ãƒƒãƒ‰ã«éš ã‚Œã‚‹åˆ†ã ã‘ãƒˆãƒªãƒ 
//
// é“è·¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ä½¿ã„åˆ†ã‘:
//   main  â†’ douro.pngï¼ˆå¹¹ç·šã€2è»Šç·šå¹…ã§ã‚¿ã‚¤ãƒ«ï¼‰
//   branchâ†’ douro_small.pngï¼ˆæ”¯ç·šã€1è»Šç·šå¹…ã§ã‚¿ã‚¤ãƒ«ã€‚ä¸Šã‚Š/ä¸‹ã‚Šãã‚Œãã‚Œã«é©ç”¨ã§è‡ªç„¶ã«è¦‹ãˆã‚‹ï¼‰
//   onewayâ†’ douro_small.pngï¼ˆ1è»Šç·šã€çŸ¢å°ä»˜ãï¼‰


// ===== é€²è¡Œæ–¹å‘ã‚µã‚¤ãƒ³æç”» =====
// å„ã‚¨ãƒƒã‚¸ã® toå´ï¼ˆäº¤å·®ç‚¹æ‰‹å‰ï¼‰ã«ã€ãã®ã‚¨ãƒƒã‚¸ã‹ã‚‰äº¤å·®ç‚¹ã‚’å‡ºãŸå¾Œã®
// é€²è¡Œå¯èƒ½æ–¹å‘ã‚’ç¤ºã™ã‚µã‚¤ãƒ³ç”»åƒã‚’è·¯é¢ã«æç”»ã™ã‚‹ã€‚
//
// åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯:
//   äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰(e.to)ã‹ã‚‰å‡ºã¦è¡Œãã‚¨ãƒƒã‚¸ç¾¤ã‚’èª¿ã¹ã€
//   å…¥ã£ã¦ããŸæ–¹å‘(e)ã¨ã®è§’åº¦å¤‰åŒ–ã§ç›´é€²/å·¦æŠ˜/å³æŠ˜ã‚’åˆ†é¡ã€‚
//   â†’ å¯èƒ½ãªæ–¹å‘ã®çµ„ã¿åˆã‚ã›ã§ä½¿ç”¨ç”»åƒã‚’æ±ºå®šã™ã‚‹ã€‚
//
// ç”»åƒã‚µã‚¤ã‚º: 15Ã—22pxï¼ˆå…ƒç”»åƒï¼‰ã‚’è·¯é¢å¹…ã«åˆã‚ã›ã¦ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
// é…ç½®: ã‚¨ãƒƒã‚¸çµ‚ç«¯ï¼ˆäº¤å·®ç‚¹ãƒ‘ãƒƒãƒ‰ã®ãƒˆãƒªãƒ å¢ƒç•Œï¼‰ã®å°‘ã—æ‰‹å‰

function getDirectionType(inEdge, outEdge){
  // å…¥ã£ã¦ãã‚‹æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
  const inDx  = inEdge.to.x  - inEdge.from.x;
  const inDy  = inEdge.to.y  - inEdge.from.y;
  // å‡ºã¦è¡Œãæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
  const outDx = outEdge.to.x - outEdge.from.x;
  const outDy = outEdge.to.y - outEdge.from.y;
  // å¤–ç©ï¼ˆæ­£=å·¦ã€è² =å³ï¼‰ã¨å†…ç©ã§è§’åº¦ã‚’è¨ˆç®—
  const cross = inDx * outDy - inDy * outDx;
  const dot   = inDx * outDx + inDy * outDy;
  const angle = Math.atan2(cross, dot); // -Ï€ã€œÏ€
  if(Math.abs(angle) < Math.PI / 6) return 'straight'; // Â±30åº¦ä»¥å†…: ç›´é€²
  if(angle > 0)                     return 'left';      // æ­£: å·¦æŠ˜
  return 'right';                                       // è² : å³æŠ˜
}

function drawDirectionSigns(){
  // å†…éƒ¨äº¤å·®ç‚¹ã¸å‘ã‹ã†ã‚¨ãƒƒã‚¸ã®ã¿å¯¾è±¡
  for(const e of edges){
    const toNode = e.to;
    if(toNode.type !== "cross" || toNode.external) continue;
    // oneway ã®é€†æ–¹å‘ã‚¨ãƒƒã‚¸ï¼ˆå®Ÿè³ªå­˜åœ¨ã—ãªã„ãŒå¿µã®ãŸã‚ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—
    // ã¾ãŸå¤–éƒ¨ãƒãƒ¼ãƒ‰ã‹ã‚‰æ¥ã‚‹ã‚¨ãƒƒã‚¸ã‚‚ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ã¯ä¸è¦ï¼‰
    if(e.from.external) continue;

    // ã“ã®ã‚¨ãƒƒã‚¸ãŒäº¤å·®ç‚¹ã‚’é€šéã—ãŸå¾Œã«é€²ã‚ã‚‹ã€Œå‡ºå£ã‚¨ãƒƒã‚¸ã€ã‚’åé›†
    // ãŸã ã—æŠ˜ã‚Šè¿”ã—ï¼ˆUã‚¿ãƒ¼ãƒ³ï¼‰ã¯é™¤å¤–
    const outEdges = edges.filter(ex =>
      ex.from === toNode &&
      // æ¥ãŸæ–¹å‘ã®é€†ï¼ˆåŒã˜ãƒãƒ¼ãƒ‰ãƒšã‚¢ã®é€†å‘ãï¼‰ã¯é™¤å¤–
      !(ex.to === e.from)
    );
    if(outEdges.length === 0) continue;

    // å„å‡ºå£ã®æ–¹å‘ã‚’åˆ¤å®š
    const dirs = new Set(outEdges.map(ex => getDirectionType(e, ex)));

    // æ–¹å‘ã®çµ„ã¿åˆã‚ã›ã§ç”»åƒã‚’é¸æŠ
    const hasSt = dirs.has('straight');
    const hasL  = dirs.has('left');
    const hasR  = dirs.has('right');

    let signKey = null;
    if(hasSt && hasL && hasR) signKey = 'st_right_left'; // å…¨æ–¹å‘
    else if(hasSt && hasL)    signKey = 'st_left';
    else if(hasSt && hasR)    signKey = 'st_right';
    else if(hasL  && hasR)    signKey = 'right_left';
    else if(hasSt)            signKey = 'straight';
    else if(hasL)             signKey = 'left';
    else if(hasR)             signKey = 'right';
    if(!signKey) continue;

    const img = signImgs[signKey];
    if(!img || !img.complete || !img.naturalWidth) continue;

    // ã‚¨ãƒƒã‚¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå˜ä½ãƒ™ã‚¯ãƒˆãƒ«ï¼‰
    const dx  = toNode.x - e.from.x;
    const dy  = toNode.y - e.from.y;
    const dist = Math.hypot(dx, dy);
    if(dist < 1) continue;
    const ux = dx / dist; // é€²è¡Œæ–¹å‘ã®å˜ä½ãƒ™ã‚¯ãƒˆãƒ« x
    const uy = dy / dist; // é€²è¡Œæ–¹å‘ã®å˜ä½ãƒ™ã‚¯ãƒˆãƒ« y
    // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ï¼ˆé€²è¡Œæ–¹å‘ã®å³ãŒæ­£ã€å·¦å´é€šè¡Œãªã®ã§å·¦=è² æ–¹å‘ï¼‰
    const nx = -uy;
    const ny =  ux;

    // trimTo: äº¤å·®ç‚¹ãƒ‘ãƒƒãƒ‰ã®ãƒˆãƒªãƒ é‡ï¼ˆãã®äº¤å·®ç‚¹ã®æœ€å¤§é“è·¯å¹…ï¼‰
    const connOut = edges.filter(e2 => e2.from === toNode || e2.to === toNode);
    const trimTo  = connOut.length > 0 ? Math.max(...connOut.map(e2 => e2.lanes * LANE_W)) : 0;

    // ã‚µã‚¤ãƒ³è¡¨ç¤ºã‚µã‚¤ã‚ºï¼ˆå…ƒç”»åƒ 15Ã—22px ã‚’ã‚„ã‚„æ‹¡å¤§ï¼‰
    const signW = 14;
    const signH = 20;

    // é“è·¯ã®é€²è¡Œæ–¹å‘è§’åº¦
    // ã‚µã‚¤ãƒ³ç”»åƒã¯ã€Œä¸Šã«é€²ã‚€é“è·¯ã€ç”¨ã«ãƒ‡ã‚¶ã‚¤ãƒ³ã•ã‚Œã¦ã„ã‚‹ã®ã§
    // é“è·¯ã®è§’åº¦ã«åˆã‚ã›ã¦å›è»¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
    // Canvas ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: xè»¸å³æ–¹å‘=0åº¦ã€‚ä¸Šæ–¹å‘ã¯ -Ï€/2ã€‚
    // ã‚¨ãƒƒã‚¸ãŒä¸Šå‘ã(angle=-Ï€/2)ã®ã¨ãå›è»¢ãªã—ã§æ­£ã—ãè¦‹ãˆã‚‹ã€‚
    // â†’ å›è»¢é‡ = angle - (-Ï€/2) = angle + Ï€/2
    const roadAngle = Math.atan2(dy, dx);         // ã‚¨ãƒƒã‚¸ã®è§’åº¦ï¼ˆå³=0, ä¸‹=Ï€/2ï¼‰
    const signRotation = roadAngle + Math.PI / 2; // ç”»åƒã‚’é“è·¯æ–¹å‘ã«åˆã‚ã›ã‚‹è£œæ­£

    // å„è»Šç·šã«ã‚µã‚¤ãƒ³ã‚’æã
    for(let ln = 0; ln < e.lanes; ln++){
      // è»Šç·šä¸­å¤®ã®æ¨ªã‚ªãƒ•ã‚»ãƒƒãƒˆé‡ï¼ˆæ³•ç·šæ–¹å‘ã€å·¦å´é€šè¡Œ=è² æ–¹å‘ï¼‰
      const lateralOffset = -(LANE_W * ln + LANE_W / 2);

      // äº¤å·®ç‚¹ãƒ‘ãƒƒãƒ‰å¢ƒç•Œã‹ã‚‰æ‰‹å‰ã®ä½ç½®ï¼ˆé€²è¡Œæ–¹å‘æ²¿ã„ï¼‰
      const alongOffset = dist - trimTo - signH / 2 - 6;
      if(alongOffset < signH) continue;

      // æç”»ä¸­å¿ƒã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’è¨ˆç®—
      const wx = e.from.x + ux * alongOffset + nx * lateralOffset;
      const wy = e.from.y + uy * alongOffset + ny * lateralOffset;

      // ä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«å›è»¢ã—ã¦æç”»
      ctx.save();
      ctx.translate(wx, wy);
      ctx.rotate(signRotation);
      ctx.drawImage(img,
        -signW / 2,
        -signH / 2,
        signW, signH
      );
      ctx.restore();
    }
  }
}

function drawIntersectionPads(){
  const kReady = kousatenImg.complete && kousatenImg.naturalWidth > 0;

  for(const n of nodes){
    if(n.type!=="cross" || n.external) continue;

    const connEdges = edges.filter(e => e.from===n || e.to===n);
    if(connEdges.length===0) continue;

    // äº¤å·®ç‚¹ã®æç”»ã‚µã‚¤ã‚º: æ¥ç¶šã‚¨ãƒƒã‚¸ã®æœ€å¤§é“è·¯å¹…ã«åˆã‚ã›ã¦ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
    // kousaten.png ã¯æ­£å…«è§’å½¢ãªã®ã§ä¸­å¿ƒã‹ã‚‰åŒã˜è·é›¢ã§æã
    // main(2è»Šç·š=36px) ãªã‚‰åŠå¾„36px â†’ 72pxæ­£æ–¹å½¢
    // å®Ÿéš›ã¯æ¥ç¶šã‚¨ãƒƒã‚¸ä¸­ã®æœ€å¤§å¹… Ã— 1.0 ã§æãï¼ˆè§’ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ï¼‰
    const maxW = Math.max(...connEdges.map(e => e.lanes * LANE_W));
    const padSize = maxW * 2; // æ­£æ–¹å½¢ã®ä¸€è¾º

    if(kReady){
      // kousaten.png ã‚’ä¸­å¿ƒã«æç”»ï¼ˆ300Ã—300px â†’ padSizeã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ï¼‰
      ctx.drawImage(kousatenImg, n.x - maxW, n.y - maxW, padSize, padSize);
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚°ãƒ¬ãƒ¼å¡—ã‚Šã¤ã¶ã—
      ctx.fillStyle = "#555";
      ctx.fillRect(n.x - maxW, n.y - maxW, padSize, padSize);
    }
  }
}

function drawRoad(e){
  const dx=e.to.x-e.from.x, dy=e.to.y-e.from.y;
  const fullDist=Math.sqrt(dx*dx+dy*dy);
  const angle=Math.atan2(dy,dx);
  const roadW=e.lanes*LANE_W;

  // äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰å´ã¯ãƒ‘ãƒƒãƒ‰ãŒæ—¢ã«æã‹ã‚Œã¦ã„ã‚‹ã®ã§ãƒˆãƒªãƒ ã™ã‚‹
  // ãƒˆãƒªãƒ é‡ = äº¤å·®ç‚¹ãƒ‘ãƒƒãƒ‰ã®åŠå¾„ = ãã®ãƒãƒ¼ãƒ‰ã«æ¥ç¶šã™ã‚‹æœ€å¤§é“è·¯å¹…
  const isInternalCross = n => n.type==="cross" && !n.external;

  function padRadius(n){
    if(!isInternalCross(n)) return 0;
    const conn = edges.filter(e2 => e2.from===n || e2.to===n);
    return conn.length > 0 ? Math.max(...conn.map(e2 => e2.lanes * LANE_W)) : 0;
  }

  const trimFrom = padRadius(e.from);
  const trimTo   = padRadius(e.to);
  const drawStart = trimFrom;
  const drawLen   = fullDist - trimFrom - trimTo;
  if(drawLen <= 1) return;

  ctx.save();
  ctx.translate(e.from.x, e.from.y);
  ctx.rotate(angle);

  // --- é“è·¯ãƒ™ãƒ¼ã‚¹è‰² ---
  ctx.fillStyle = e.type==="oneway" ? "#4a4a5a" : "#555";
  ctx.fillRect(drawStart, -roadW, drawLen, roadW);

  // --- ãƒ†ã‚¯ã‚¹ãƒãƒ£æç”»ï¼ˆclip ã§ç¯„å›²åˆ¶é™ï¼‰---
  ctx.save();
  ctx.beginPath();
  ctx.rect(drawStart, -roadW, drawLen, roadW);
  ctx.clip();

  if(e.type==="oneway"){
    // oneway: douro_small.pngï¼ˆ1è»Šç·šå¹…ï¼‰
    if(onewayImg.complete && onewayImg.naturalWidth > 0){
      const tileW = 67;
      let x = drawStart - ((drawStart|0) % tileW);
      while(x < drawStart + drawLen){
        ctx.drawImage(onewayImg, x, -roadW, tileW, roadW);
        x += tileW;
      }
    }
  } else if(e.type==="branch"){
    // branch: douro_small.png ã‚’1è»Šç·šå¹…ã§ã‚¿ã‚¤ãƒ«
    // ä¸Šã‚Š/ä¸‹ã‚Šä¸¡ã‚¨ãƒƒã‚¸ã«ãã‚Œãã‚Œé©ç”¨ã™ã‚‹ã“ã¨ã§åŒæ–¹å‘ãŒè‡ªç„¶ã«è¦‹ãˆã‚‹
    if(onewayImg.complete && onewayImg.naturalWidth > 0){
      const tileW = 67;
      let x = drawStart - ((drawStart|0) % tileW);
      while(x < drawStart + drawLen){
        ctx.drawImage(onewayImg, x, -roadW, tileW, roadW);
        x += tileW;
      }
    } else {
      ctx.fillStyle = "#4a4a5a";
      ctx.fillRect(drawStart, -roadW, drawLen, roadW);
    }
  } else {
    // main: douro.pngï¼ˆå¹¹ç·šç”¨ï¼‰
    if(roadImg.complete && roadImg.naturalWidth > 0){
      let x = drawStart - ((drawStart|0) % 60);
      while(x < drawStart + drawLen){
        ctx.drawImage(roadImg, x, -roadW, 60, roadW);
        x += 60;
      }
    }
  }

  ctx.restore(); // clip è§£é™¤

  // --- ä¸€æ–¹é€šè¡ŒçŸ¢å° ---
  if(e.type==="oneway"){
    ctx.fillStyle="rgba(255,255,100,0.85)";
    ctx.font=`bold ${Math.max(10,roadW-2)}px sans-serif`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    const step=80;
    for(let x=drawStart+step/2; x<drawStart+drawLen; x+=step){
      ctx.fillText("â–¶", x, -roadW/2);
    }
  }

  // --- è»Šç·šä¸­å¤®ç·šï¼ˆmain ã®ã¿ï¼‰---
  if(e.type==="main"){
    ctx.strokeStyle="rgba(255,255,255,0.55)";
    ctx.setLineDash([10,8]);
    ctx.lineWidth=1.5;
    for(let ln=1; ln<e.lanes; ln++){
      ctx.beginPath();
      ctx.moveTo(drawStart, -ln*LANE_W);
      ctx.lineTo(drawStart+drawLen, -ln*LANE_W);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  ctx.restore();
}

// ===== UI =====
document.getElementById("flowSlider").oninput=function(){
  flowRate=parseInt(this.value)/100;
  document.getElementById("flowVal").textContent=this.value;
};
document.getElementById("greenSlider").oninput=function(){
  if(selectedNode){
    selectedNode.greenDuration=parseInt(this.value);
    document.getElementById("greenVal").textContent=selectedNode.greenDuration;
  }
};
canvas.onclick=ev=>{
  const r=canvas.getBoundingClientRect();
  const mx=ev.clientX-r.left, my=ev.clientY-r.top;
  for(const n of nodes){
    if(!n.external&&n.type==="cross"&&Math.abs(mx-n.x)<15&&Math.abs(my-n.y)<15){
      selectedNode=n;
      document.getElementById("greenSlider").value=n.greenDuration;
      document.getElementById("greenVal").textContent=n.greenDuration;
    }
  }
};

// ===== å·æç”» =====
function drawRivers(){
  for(const r of rivers){
    if(r.type==="h"){
      // ---- æ°´å¹³å· ----
      const w = 1000, h = r.y2 - r.y1;
      if(riverImg.complete && riverImg.naturalWidth > 0){
        // ç”»åƒã‚’æ¨ªã«ã‚¿ã‚¤ãƒ«ï¼ˆãã®ã¾ã¾æç”»ã€å›è»¢ãªã—ï¼‰
        const tw = 128;
        for(let x = 0; x < w; x += tw){
          ctx.drawImage(riverImg, x, r.y1, Math.min(tw, w - x), h);
        }
      } else {
        const grad = ctx.createLinearGradient(0, r.y1, 0, r.y2);
        grad.addColorStop(0,   "#4a9fc7");
        grad.addColorStop(0.3, "#2e86c1");
        grad.addColorStop(0.7, "#2e86c1");
        grad.addColorStop(1,   "#4a9fc7");
        ctx.fillStyle = grad;
        ctx.fillRect(0, r.y1, w, h);
      }
      // æ¨ªæ–¹å‘ã®æ³¢ç´‹ãƒ©ã‚¤ãƒ³
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1.5;
      const hStep = Math.max(10, h / 4);
      for(let y = r.y1 + hStep * 0.5; y < r.y2; y += hStep){
        ctx.beginPath();
        for(let x = 0; x <= 1000; x += 8){
          const wave = Math.sin((x * 0.05) + timeCounter * 0.04) * 2.5;
          x === 0 ? ctx.moveTo(x, y + wave) : ctx.lineTo(x, y + wave);
        }
        ctx.stroke();
      }

    } else {
      // ---- ç¸¦å· ----
      // å›è»¢ã¯ä½¿ã‚ãšã€ç¸¦æ–¹å‘ã«ã‚¿ã‚¤ãƒ«ã‚’ç©ã¿ä¸Šã’ã‚‹ã ã‘
      const cw = r.x2 - r.x1, ch = 700;
      if(riverImg.complete && riverImg.naturalWidth > 0){
        // ç¸¦ã«ã‚¿ã‚¤ãƒ«ã‚’ä¸¦ã¹ã‚‹ï¼ˆç”»åƒã®é«˜ã•128pxã‚’å·å¹…ã«æ‹¡ç¸®ã—ã¦ç©ã‚€ï¼‰
        const th = 128;
        for(let y = 0; y < ch; y += th){
          ctx.drawImage(riverImg, r.x1, y, cw, Math.min(th, ch - y));
        }
      } else {
        const grad = ctx.createLinearGradient(r.x1, 0, r.x2, 0);
        grad.addColorStop(0,   "#4a9fc7");
        grad.addColorStop(0.3, "#2e86c1");
        grad.addColorStop(0.7, "#2e86c1");
        grad.addColorStop(1,   "#4a9fc7");
        ctx.fillStyle = grad;
        ctx.fillRect(r.x1, 0, cw, ch);
      }
      // ç¸¦æ–¹å‘ã®æ³¢ç´‹ãƒ©ã‚¤ãƒ³
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1.5;
      const vStep = Math.max(10, cw / 4);
      for(let x = r.x1 + vStep * 0.5; x < r.x2; x += vStep){
        ctx.beginPath();
        for(let y = 0; y <= 700; y += 8){
          const wave = Math.sin((y * 0.05) + timeCounter * 0.04) * 2.5;
          y === 0 ? ctx.moveTo(x + wave, y) : ctx.lineTo(x + wave, y);
        }
        ctx.stroke();
      }
    }
  }
}

// ===== åœ°å½¢æç”» =====
function drawTerrain(){
  if(terrainCanvas){
    ctx.drawImage(terrainCanvas, 0, 0);
  }
}

// ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
// äº‹æ•…ç™ºç”Ÿã‚¿ã‚¤ãƒãƒ¼ï¼ˆå¹³å‡120ç§’ã«1å› = 7200ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
let nextAccidentIn = 3600 + Math.floor(Math.random()*3600);

function loop(){
  ctx.clearRect(0,0,1000,700);
  updateTime();
  nodes.forEach(n=>n.update());

  // äº‹æ•…ç™ºç”Ÿã‚¿ã‚¤ãƒãƒ¼
  nextAccidentIn--;
  if(nextAccidentIn<=0 && cars.length>3){
    triggerAccident();
    nextAccidentIn=3600+Math.floor(Math.random()*3600); // æ¬¡ã®äº‹æ•…ã¾ã§60ã€œ120ç§’
  }
  updateAccidents();

  drawTerrain();              // â‘  åœ°å½¢ï¼ˆæœ€èƒŒé¢ï¼‰
  drawRivers();               // â‘¡ å·
  // â‘¢ é“è·¯æç”»: å„ªå…ˆé †ä½ branch/oneway â†’ main â†’ äº¤å·®ç‚¹ãƒ‘ãƒƒãƒ‰
  // å¾Œã‹ã‚‰æã„ãŸã‚‚ã®ãŒä¸Šã«æ¥ã‚‹ã®ã§ã€é‡è¦ãªé“è·¯ã‚’å¾Œã§æã
  edges.filter(e=>e.type!=="main").forEach(e=>drawRoad(e)); // â‘¢-a æ”¯ç·šãƒ»ä¸€æ–¹é€šè¡Œï¼ˆä¸‹ï¼‰
  edges.filter(e=>e.type==="main").forEach(e=>drawRoad(e)); // â‘¢-b å¹¹ç·šï¼ˆä¸­ï¼‰
  drawIntersectionPads();     // â‘¢-c äº¤å·®ç‚¹ãƒ‘ãƒƒãƒ‰ï¼ˆæœ€ä¸Šä½ã€å…¨é“è·¯ã‚’è¦†ã†ï¼‰
  drawDirectionSigns();       // â‘¢-d é€²è¡Œæ–¹å‘ã‚µã‚¤ãƒ³ï¼ˆäº¤å·®ç‚¹æ‰‹å‰ã®è·¯é¢ã«æç”»ï¼‰
  for(const c of cars) c.update();
  for(let i=cars.length-1;i>=0;i--) if(!cars[i].alive) cars.splice(i,1);
  let jam=0;
  for(const c of cars){ c.draw(); if(c.wait>60) jam++; }
  drawAccidents();        // â‘£ äº‹æ•…ãƒãƒ¼ã‚«ãƒ¼
  drawReverseHighlight(); // â‘¤ åè»¢ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  nodes.forEach(n=>n.draw());
  document.getElementById("jam").textContent=jam;
  updateScore(jam);
  requestAnimationFrame(loop);
}

// ===== ç”»åƒãƒ­ãƒ¼ãƒ‰ =====
function waitForImages(imgs,cb){
  let rem=imgs.length; if(rem===0){cb();return;}
  let done=false;
  const tick=()=>{ if(--rem<=0&&!done){done=true;cb();} };
  for(const img of imgs){ if(img.complete) tick(); else{ img.onload=tick; img.onerror=tick; } }
}
const allImgs=[roadImg,onewayImg,parkImg,parkingImg,riverImg,...groundImgs,sigGreenImg,sigRedImg,kousatenImg,...Object.values(signImgs),policeImg,...carImgs,...houseImgs,...companyImgs];
waitForImages(allImgs,()=>{ generateCity(); loop(); console.log("âœ… v21 èµ·å‹•"); });
setTimeout(()=>{ if(!timeCounter){ generateCity(); loop(); console.warn("âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯"); } },5000);
</script>
</body>
</html>
