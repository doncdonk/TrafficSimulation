<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>éƒ½å¸‚äº¤é€šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ v21</title>
<style>
body { margin:0; background:#1e1e1e; color:white; font-family:sans-serif; }
#ui { padding:8px; text-align:center; font-size:14px; }
canvas { background:#2b2b2b; display:block; margin:auto; }
input { width:160px; }
#scoreBar {
  display:flex; justify-content:center; align-items:center; gap:20px;
  padding:6px 0; background:#111; border-bottom:1px solid #333;
  font-size:15px; letter-spacing:0.5px;
}
#scoreVal { font-size:22px; font-weight:bold; color:#f0c040; }
#rankVal  { font-size:18px; font-weight:bold; }
#accVal   { color:#ff6060; }
#bonusVal { color:#60d0ff; font-size:12px; }
.rank-S { color:#ff4fff; }
.rank-A { color:#ffaa00; }
.rank-B { color:#80e060; }
.rank-C { color:#60b0ff; }
.rank-D { color:#aaaaaa; }
</style>
</head>
<body>
<div id="scoreBar">
  <span>SCORE: <span id="scoreVal">0</span></span>
  <span>RANK: <span id="rankVal" class="rank-B">B</span></span>
  <span id="bonusVal">BONUS Ã—1.0</span>
  <span>äº‹æ•…: <span id="accVal">0</span>ä»¶</span>
</div>
<div id="ui">
  æµå…¥é‡: <input type="range" id="flowSlider" min="0" max="100" value="50"><span id="flowVal">50</span>
  |
  äº¤å·®ç‚¹é’æ™‚é–“: <input type="range" id="greenSlider" min="60" max="300" value="120"><span id="greenVal">120</span>
  |
  æ™‚é–“å¸¯: <span id="timeLabel">Day</span>
  |
  æ¸‹æ»: <span id="jam">0</span>
  | ç·Šæ€¥å¯¾å¿œ(-300pt): <button id="clearAccBtn" onclick="clearAccident()">ğŸš¨ å¯¾å¿œ</button>
</div>
<canvas id="game" width="1000" height="700"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nodes = [], edges = [], cars = [];
const rivers = []; // å·ãƒ‡ãƒ¼ã‚¿: [{type:"h"|"v", y1,y2} or {x1,x2}]
let terrainCanvas = null; // åœ°å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£(ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã€generateCityæ™‚ã«ç”Ÿæˆ)
let selectedNode = null, timeCounter = 0, flowRate = 0.5;

// ===== ã‚¹ã‚³ã‚¢ãƒ»äº‹æ•… =====
let score = 0;
let scoreBonus = 1.0;     // æ¸‹æ»ã‚¼ãƒ­ç¶™ç¶šã§ãƒœãƒ¼ãƒŠã‚¹å€ç‡UP
let bonusStreak = 0;      // æ¸‹æ»ã‚¼ãƒ­ç¶™ç¶šãƒ•ãƒ¬ãƒ¼ãƒ æ•°
const accidents = [];     // äº‹æ•…ãƒªã‚¹ãƒˆ [{x,y,edge,timer,maxTimer,blink}]
let accidentCount = 0;    // ç´¯è¨ˆäº‹æ•…ä»¶æ•°
const ACCIDENT_DURATION = 1800; // äº‹æ•…ç¶™ç¶šæ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ã€ç´„30ç§’@60fpsï¼‰
const ACCIDENT_SLOWZONE = 80;   // äº‹æ•…å½±éŸ¿ç¯„å›²ï¼ˆpxï¼‰

const MIN_GAP  = 20;   // å‰è»Šã¨ã®æœ€å°è·é›¢(px)
const SLOW_GAP = 60;   // æ¸›é€Ÿé–‹å§‹è·é›¢(px)
const LANE_W   = 18;   // 1è»Šç·šã®å¹…(px)

// ===== ç”»åƒ =====
const roadImg      = new Image(); roadImg.src      = "douro.png";
const onewayImg    = new Image(); onewayImg.src    = "douro_small.png";
const parkImg      = new Image(); parkImg.src      = "park1.png";
const parkingImg   = new Image(); parkingImg.src   = "parking.png";
const riverImg     = new Image(); riverImg.src     = "river.png";
const sigGreenImg  = new Image(); sigGreenImg.src  = "shingou_blue.png";
const sigRedImg    = new Image(); sigRedImg.src    = "shingou_red.png";
const carImgs   = Array.from({length:10}, (_,i)=>{ const m=new Image(); m.src=`car${i+1}.png`;   return m; });
const houseImgs = Array.from({length:8},  (_,i)=>{ const m=new Image(); m.src=`house${i+1}.png`; return m; });

// ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
function linesIntersect(p1,p2,p3,p4){
  if(p1===p3||p1===p4||p2===p3||p2===p4) return false;
  const ccw=(a,b,c)=>(c.y-a.y)*(b.x-a.x)>(b.y-a.y)*(c.x-a.x);
  return ccw(p1,p3,p4)!==ccw(p2,p3,p4) && ccw(p1,p2,p3)!==ccw(p1,p2,p4);
}

// ===== Node =====
class Node {
  constructor(x,y,type="cross",external=false,img=null){
    this.x=x; this.y=y; this.type=type; this.external=external; this.img=img;
    this.phase=0; this.timer=0; this.greenDuration=120;
  }
  update(){
    if(this.external || this.type!=="cross") return;
    if(++this.timer >= this.greenDuration){ this.phase=(this.phase+1)%2; this.timer=0; }
  }
  draw(){
    if(this.type==="house"||this.type==="park"){
      if(this.img) ctx.drawImage(this.img, this.x-20, this.y-20, 40, 40);
      return;
    }
    if(this.type==="parking"){
      if(parkingImg.complete&&parkingImg.naturalWidth>0){
        ctx.drawImage(parkingImg, this.x-30, this.y-30, 60, 60);
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é’ã„é§è»Šå ´ãƒãƒ¼ã‚¯
        ctx.fillStyle="#1a6bb5";
        ctx.fillRect(this.x-30, this.y-30, 60, 60);
        ctx.fillStyle="white";
        ctx.font="bold 28px sans-serif";
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.fillText("P", this.x, this.y);
      }
      return;
    }
    ctx.fillStyle = this.external ? "#444" : "#666";
    ctx.fillRect(this.x-15, this.y-15, 30, 30);
    if(this.external) return;

    // ä¿¡å·: ã“ã®ãƒãƒ¼ãƒ‰ã‚’fromã¨ã™ã‚‹ã‚¨ãƒƒã‚¸ã®æ–¹å‘ã‚’è¦‹ã‚‹
    const outEdges = edges.filter(e=>e.from===this);
    const dirs = {up:false,down:false,left:false,right:false};
    for(const e of outEdges){
      const dx=e.to.x-this.x, dy=e.to.y-this.y;
      if(Math.abs(dy)>Math.abs(dx)){ if(dy<0) dirs.up=true; else dirs.down=true; }
      else                          { if(dx<0) dirs.left=true; else dirs.right=true; }
    }
    const vG=this.phase===0, hG=this.phase===1;

    // ä¿¡å·ç”»åƒã®æç”»
    // ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯å¾“æ¥ã®çŸ©å½¢ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    const sigReady = sigGreenImg.complete && sigGreenImg.naturalWidth > 0
                  && sigRedImg.complete  && sigRedImg.naturalWidth  > 0;

    // ä¿¡å·1ã¤ã‚’æç”»ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
    // cx,cy: æç”»ä¸­å¿ƒåº§æ¨™, angle: å›è»¢è§’(rad), isGreen: é’ã‹èµ¤ã‹
    function drawSignal(cx, cy, angle, isGreen){
      const img = isGreen ? sigGreenImg : sigRedImg;
      const W = 40, H = 15; // æç”»ã‚µã‚¤ã‚º (400x150 ã® 1/10)
      if(sigReady){
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.drawImage(img, -W/2, -H/2, W, H);
        ctx.restore();
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è‰²ä»˜ãçŸ©å½¢
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.fillStyle = isGreen ? "#0f0" : "#f00";
        ctx.fillRect(-W/2, -H/2, W, H);
        ctx.restore();
      }
    }

    // å„æ–¹å‘ã«ä¿¡å·ã‚’é…ç½®
    // ç”»åƒã¯æ¨ªé•·(400Ã—150px)ã§å·¦ç«¯ãŒé’ç¯å´ã€‚
    // ä¿¡å·ã¯é“è·¯ã‚ãã«ã€Œè»ŠãŒæ¥ã‚‹æ–¹å‘ã‚’å‘ã„ã¦ã€ç¸¦ã«ç«‹ã¦ã‚‹ã€‚
    //
    // right(å³èµ°è¡Œ)ã®ä¿¡å·: é“è·¯ä¸Šå´ã«ç«‹ã¡ã€å³ã‚’å‘ã â†’ ç”»åƒã‚’-90åº¦å›è»¢
    // left (å·¦èµ°è¡Œ)ã®ä¿¡å·: é“è·¯ä¸‹å´ã«ç«‹ã¡ã€å·¦ã‚’å‘ã â†’ ç”»åƒã‚’+90åº¦å›è»¢
    // down (ä¸‹èµ°è¡Œ)ã®ä¿¡å·: é“è·¯å·¦å´ã«ç«‹ã¡ã€ä¸‹ã‚’å‘ã â†’ ç”»åƒã‚’0åº¦(æ¨ªãã®ã¾ã¾)
    // up  (ä¸Šèµ°è¡Œ)ã®ä¿¡å·: é“è·¯å³å´ã«ç«‹ã¡ã€ä¸Šã‚’å‘ã â†’ ç”»åƒã‚’180åº¦å›è»¢
    const SIG_DIST = 26; // äº¤å·®ç‚¹ä¸­å¿ƒã‹ã‚‰ã®è·é›¢(px)
    if(dirs.up)    drawSignal(this.x,             this.y - SIG_DIST,  Math.PI,      vG);
    if(dirs.down)  drawSignal(this.x,             this.y + SIG_DIST,  0,            vG);
    if(dirs.left)  drawSignal(this.x - SIG_DIST,  this.y,             Math.PI/2,    hG);
    if(dirs.right) drawSignal(this.x + SIG_DIST,  this.y,            -Math.PI/2,    hG);
  }
}

// ===== Edge =====
// â˜… å…¨ã‚¨ãƒƒã‚¸ã¯ fromâ†’to ã®ä¸€æ–¹é€šè¡Œã€‚
// main: åŒæ–¹å‘2è»Šç·š(ç‰‡å´2ãƒ¬ãƒ¼ãƒ³)
// branch: åŒæ–¹å‘1è»Šç·š
// åå¯¾æ–¹å‘ã®äº¤é€šã¯åˆ¥ã‚¨ãƒƒã‚¸ã¨ã—ã¦ç‹¬ç«‹å®šç¾©ã™ã‚‹ã€‚
class Edge {
  constructor(from,to,type="branch"){
    this.from=from; this.to=to; this.type=type;
    // main: 2è»Šç·š  oneway: 1è»Šç·š(é€†å‘ãã‚¨ãƒƒã‚¸ãªã—)  branch: 1è»Šç·š
    this.lanes = (type==="main") ? 2 : 1;
    this.length = Math.hypot(to.x-from.x, to.y-from.y);
    this.laneCars = Array.from({length:this.lanes}, ()=>[]);
  }
}

// ===== Car =====
// â˜… å·¦å´é€šè¡Œã®åŸå‰‡:
//   nx = (-vy/len, vx/len) ã¯Canvas(Yä¸‹å‘ã)ä¸Šã§é€²è¡Œæ–¹å‘ã®å³å´ãŒæ­£ã€‚
//   å·¦å´ = nxè² æ–¹å‘ â†’ offset = -(LANE_W/2 + lane * LANE_W)
//   lane0: ä¸­å¤®å¯„ã‚Š(offset = -LANE_W/2)
//   lane1: å¤–å´    (offset = -LANE_W/2 - LANE_W)
let carCounter=0;
class Car {
  constructor(route, img){
    this.id=carCounter++;
    this.route=route;   // [{edge, lane}, ...]
    this.routeIdx=0;
    this.edge=route[0].edge;
    this.lane=route[0].lane;
    this.pos=0.02;
    this.speed=0;
    this.maxSpeed=1+Math.random()*1.2;
    this.wait=0;
    this.img=img;
    this.alive=true;
    this.edge.laneCars[this.lane].push(this);
  }

  update(){
    if(!this.alive) return;
    const laneArr=this.edge.laneCars[this.lane];

    // å‰æ–¹è»Šã¨ã®è»Šé–“ã§é€Ÿåº¦æ±ºå®š
    const ahead=laneArr.filter(c=>c.pos>this.pos).sort((a,b)=>a.pos-b.pos)[0];
    let target=this.maxSpeed;
    if(ahead){
      const gap=(ahead.pos-this.pos)*this.edge.length;
      if(gap<MIN_GAP){ target=0; this.wait++; }
      else if(gap<SLOW_GAP) target=this.maxSpeed*(gap/SLOW_GAP);
    }

    // ä¿¡å·åˆ¤å®š: æ¬¡ã®ãƒãƒ¼ãƒ‰(to)ãŒå†…éƒ¨äº¤å·®ç‚¹ãªã‚‰ä¿¡å·ã‚’ç¢ºèª
    const toNode=this.edge.to;
    if(toNode.type==="cross" && !toNode.external && this.pos>0.85){
      const dx=this.edge.to.x-this.edge.from.x;
      const dy=this.edge.to.y-this.edge.from.y;
      const isVert=Math.abs(dy)>Math.abs(dx);
      const canGo=isVert?(toNode.phase===0):(toNode.phase===1);
      if(!canGo){ target=0; this.wait++; }
    }

    // äº‹æ•…ã‚¾ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯: è¿‘ãã«äº‹æ•…ãŒã‚ã‚Œã°å¼·åˆ¶æ¸›é€Ÿ
    const {from:ef,to:et}=this.edge;
    const carX=ef.x+(et.x-ef.x)*this.pos;
    const carY=ef.y+(et.y-ef.y)*this.pos;
    for(const acc of accidents){
      if(Math.hypot(carX-acc.x, carY-acc.y) < ACCIDENT_SLOWZONE){
        target=Math.min(target, 0.2); // å¾è¡Œ
        this.wait++;
        break;
      }
    }

    this.speed+=(target-this.speed)*0.2;
    this.pos+=this.speed/this.edge.length;
    this.pos=Math.min(this.pos,1);

    if(this.pos>=1){
      const idx=laneArr.indexOf(this);
      if(idx!==-1) laneArr.splice(idx,1);
      this.routeIdx++;
      if(this.routeIdx>=this.route.length){
        this.alive=false;
        // ç›®çš„åœ°åˆ°ç€ã§ã‚¹ã‚³ã‚¢åŠ ç®—
        score += Math.round(100 * scoreBonus);
        return;
      }
      const next=this.route[this.routeIdx];
      this.edge=next.edge;
      this.lane=next.lane;
      this.pos=0.02;
      this.edge.laneCars[this.lane].push(this);
    }
  }

  draw(){
    if(!this.alive) return;
    const {from,to}=this.edge;
    const vx=to.x-from.x, vy=to.y-from.y;
    const len=Math.sqrt(vx*vx+vy*vy);
    const nx=-vy/len, ny=vx/len;

    // å·¦å´é€šè¡Œ: nxè² æ–¹å‘(é€²è¡Œå·¦å´)ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    const offset=-(LANE_W/2 + this.lane*LANE_W);
    const cx=from.x+vx*this.pos+nx*offset;
    const cy=from.y+vy*this.pos+ny*offset;
    const angle=Math.atan2(vy,vx);

    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(angle);
    if(this.img&&this.img.complete&&this.img.naturalWidth>0){
      ctx.drawImage(this.img,-10,-6,20,12);
    } else {
      ctx.fillStyle="yellow";
      ctx.fillRect(-6,-4,12,8);
    }
    ctx.restore();
  }
}


// ===== éƒ½å¸‚ç”Ÿæˆ =====
// è¨­è¨ˆ:
//  1. å¹¹ç·š(arterial): æ°´å¹³2ã€œ3æœ¬ + å‚ç›´2ã€œ3æœ¬ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
//     â†’ äº¤ç‚¹ã‚’è‡ªå‹•è¨ˆç®—ã—ãƒãƒ¼ãƒ‰åŒ– â†’ å¤šæ§˜ãªæ§‹é€ ãƒ‘ã‚¿ãƒ¼ãƒ³
//  2. æ”¯ç·š(branch): ä¸»è¦é“è·¯ã®ã€Œé€”ä¸­ã€ã‹ã‚‰Tå­—è·¯ã¨ã—ã¦æåˆ†ã‹ã‚Œ
//     â†’ ã‚¨ãƒƒã‚¸ã‚’ä¸­é–“ãƒãƒ¼ãƒ‰ã§åˆ†å‰²ã—ã€ãã“ã‹ã‚‰å‚ç›´æ–¹å‘ã«ä¼¸ã°ã™
//  å…¨ã‚¨ãƒƒã‚¸ã¯ä¸€æ–¹é€šè¡Œãƒšã‚¢(Aâ†’B ã¨ Bâ†’A)ã€‚

function generateCity(){
  nodes.length=0; edges.length=0; cars.length=0;
  accidents.length=0; score=0; scoreBonus=1.0; bonusStreak=0; accidentCount=0;

  // ================================================================
  // ãƒ˜ãƒ«ãƒ‘ãƒ¼
  // ================================================================
  function mkNode(x,y,type="cross",ext=false,img=null){
    const n=new Node(x,y,type,ext,img); nodes.push(n); return n;
  }

  // ç‚¹pã‹ã‚‰ç·šåˆ†(a,b)ã¸ã®è·é›¢
  function ptSegDist(p,a,b){
    const dx=b.x-a.x,dy=b.y-a.y,l2=dx*dx+dy*dy;
    if(l2===0) return Math.hypot(p.x-a.x,p.y-a.y);
    const t=Math.max(0,Math.min(1,((p.x-a.x)*dx+(p.y-a.y)*dy)/l2));
    return Math.hypot(p.x-a.x-dx*t, p.y-a.y-dy*t);
  }

  // ã‚¨ãƒƒã‚¸è¿½åŠ ã®å³å¯†ãƒã‚§ãƒƒã‚¯
  // â‘  æœ€å°é•·  â‘¡ é‡è¤‡  â‘¢ äº¤å·®  â‘£ ä¸­é–“éƒ¨åˆ†ã®è¿‘æ¥å¹³è¡Œï¼ˆç«¯ç‚¹ã¯é™¤å¤–ï¼‰
  function canAdd(a,b,minLen=50){
    if(Math.hypot(b.x-a.x,b.y-a.y)<minLen) return false;
    if(edges.some(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a))) return false;
    const vx=b.x-a.x,vy=b.y-a.y,vl=Math.hypot(vx,vy);
    for(const e of edges){
      if(linesIntersect(a,b,e.from,e.to)) return false;
      const ex=e.to.x-e.from.x,ey=e.to.y-e.from.y,el=Math.hypot(ex,ey);
      if(el<1) continue;
      if(Math.abs((vx*ex+vy*ey)/(vl*el))<0.90) continue; // å¹³è¡Œã§ãªã„
      // ä¸­é–“ç‚¹(25/50/75%)ã§è¿‘æ¥ãƒã‚§ãƒƒã‚¯ï¼ˆç«¯ç‚¹é™¤å¤–ã§äº¤å·®ç‚¹èª¤åˆ¤å®šã‚’é˜²ãï¼‰
      const near=[0.25,0.5,0.75].some(t=>{
        const px=a.x+vx*t, py=a.y+vy*t;
        return ptSegDist({x:px,y:py},e.from,e.to)<38;
      });
      if(near) return false;
    }
    return true;
  }

  function addPair(a,b,type){
    if(!canAdd(a,b)) return false;
    edges.push(new Edge(a,b,type));
    edges.push(new Edge(b,a,type));
    return true;
  }

  // 2ç·šåˆ†ã®äº¤ç‚¹ã‚’è¨ˆç®—ï¼ˆå¹³è¡Œãƒ»éäº¤å·®æ™‚ã¯nullï¼‰
  function segIntersection(p1,p2,p3,p4){
    const d1x=p2.x-p1.x, d1y=p2.y-p1.y;
    const d2x=p4.x-p3.x, d2y=p4.y-p3.y;
    const cross=d1x*d2y-d1y*d2x;
    if(Math.abs(cross)<0.001) return null;
    const t=((p3.x-p1.x)*d2y-(p3.y-p1.y)*d2x)/cross;
    const u=((p3.x-p1.x)*d1y-(p3.y-p1.y)*d1x)/cross;
    if(t<0.05||t>0.95||u<0.05||u>0.95) return null; // ç«¯ç‚¹ä»˜è¿‘ã¯é™¤å¤–
    return {x:p1.x+d1x*t, y:p1.y+d1y*t};
  }

  // ================================================================
  // 1. å¹¹ç·š(arterial) â€” æ°´å¹³ç·šãƒ»å‚ç›´ç·šã‚’ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ã—ã¦äº¤ç‚¹ãƒãƒ¼ãƒ‰ç”Ÿæˆ
  // ================================================================

  // æ°´å¹³ç·š: 2ã€œ3æœ¬ã€yåº§æ¨™ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
  const numH=2+Math.floor(Math.random()*2);  // 2ã€œ3æœ¬
  const numV=2+Math.floor(Math.random()*2);  // 2ã€œ3æœ¬

  // yåº§æ¨™: 150ã€œ560ã®ç¯„å›²ã§å‡ç­‰åˆ†å‰²ï¼‹ãƒ©ãƒ³ãƒ€ãƒ ã‚¸ãƒƒã‚¿ãƒ¼
  function randLines(count, lo, hi){
    const step=(hi-lo)/(count+1);
    return Array.from({length:count},(_,i)=>
      Math.round(lo+step*(i+1)+(Math.random()-0.5)*step*0.4)
    );
  }
  const hYs=randLines(numH,130,570);  // æ°´å¹³ç·šã®yåº§æ¨™
  const vXs=randLines(numV,180,820);  // å‚ç›´ç·šã®xåº§æ¨™

  // å„æ°´å¹³ãƒ»å‚ç›´ç·šã‚’ã€Œç„¡é™é•·ã®ç›´ç·šã€ã¨ã—ã¦å®šç¾©ã—ã€å¾Œã§äº¤ç‚¹ã§ãƒãƒ¼ãƒ‰åŒ–
  // æ°´å¹³ç·š: y=hY, x: 0â†’1000
  // å‚ç›´ç·š: x=vX, y: 0â†’700

  // ----------------------------------------------------------------
  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ç”Ÿæˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
  //  ãƒ‘ã‚¿ãƒ¼ãƒ³Aï¼ˆ40%ï¼‰: å…¨å¹¹ç·šã«å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚ã‚Šï¼ˆå¾“æ¥é€šã‚Šï¼‰
  //  ãƒ‘ã‚¿ãƒ¼ãƒ³Bï¼ˆ35%ï¼‰: ä¸€éƒ¨ã®å¹¹ç·šç«¯ã®ã¿å¤–éƒ¨ãƒãƒ¼ãƒ‰ï¼ˆé–“å¼•ãï¼‰
  //  ãƒ‘ã‚¿ãƒ¼ãƒ³Cï¼ˆ25%ï¼‰: å¤–éƒ¨ãƒãƒ¼ãƒ‰ãŒéå¸¸ã«å°‘ãªã„ï¼ˆå†…å´ã®éƒ½å¸‚ã®ã¿ï¼‰
  // ----------------------------------------------------------------
  const extPattern = Math.random();
  // å„ç«¯ç‚¹ã«å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚’ä½œã‚‹ã‹æ±ºã‚ã‚‹é–¢æ•°
  function shouldMakeExt(patternRoll){
    if(patternRoll < 0.40) return true;          // ãƒ‘ã‚¿ãƒ¼ãƒ³A: å…¨éƒ¨ä½œã‚‹
    if(patternRoll < 0.75) return Math.random() < 0.55; // ãƒ‘ã‚¿ãƒ¼ãƒ³B: 55%ã§ä½œã‚‹
    return Math.random() < 0.25;                 // ãƒ‘ã‚¿ãƒ¼ãƒ³C: 25%ã§ä½œã‚‹
  }

  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ã‚’å¹¹ç·šã®ç«¯ç‚¹ã¨ã—ã¦ä½œæˆï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¿œã˜ã¦é–“å¼•ãï¼‰
  const hExtL=hYs.map(y=> shouldMakeExt(extPattern) ? mkNode(0,   y,"cross",true) : null);
  const hExtR=hYs.map(y=> shouldMakeExt(extPattern) ? mkNode(1000,y,"cross",true) : null);
  const vExtT=vXs.map(x=> shouldMakeExt(extPattern) ? mkNode(x,  0,"cross",true) : null);
  const vExtB=vXs.map(x=> shouldMakeExt(extPattern) ? mkNode(x,700,"cross",true) : null);

  // äº¤ç‚¹ãƒãƒ¼ãƒ‰ãƒãƒˆãƒªã‚¯ã‚¹: crossPt[hi][vi] = {x,y} ã®äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰
  const crossPt=hYs.map((hy,hi)=>
    vXs.map((vx,vi)=>mkNode(vx,hy,"cross"))
  );

  // æ°´å¹³å¹¹ç·šã‚’å„è¡Œã§å·¦ç«¯â†’äº¤ç‚¹â†’â€¦â†’å³ç«¯ã¨ã‚¨ãƒƒã‚¸ã§ç¹‹ãï¼ˆå¤–éƒ¨ãƒãƒ¼ãƒ‰ãŒnullãªã‚‰ç«¯ç‚¹ã¾ã§å»¶ã°ã•ãªã„ï¼‰
  for(let hi=0;hi<numH;hi++){
    const row=[hExtL[hi], ...crossPt[hi], hExtR[hi]].filter(n=>n!==null);
    for(let i=0;i<row.length-1;i++) addPair(row[i],row[i+1],"main");
  }
  // å‚ç›´å¹¹ç·šã‚’å„åˆ—ã§ä¸Šç«¯â†’äº¤ç‚¹â†’â€¦â†’ä¸‹ç«¯ã¨ã‚¨ãƒƒã‚¸ã§ç¹‹ã
  for(let vi=0;vi<numV;vi++){
    const col=[vExtT[vi], ...crossPt.map(r=>r[vi]), vExtB[vi]].filter(n=>n!==null);
    for(let i=0;i<col.length-1;i++) addPair(col[i],col[i+1],"main");
  }

  // ================================================================
  // 2. æ”¯ç·š(branch) â€” 2ç¨®é¡ã®ç”Ÿæˆæ–¹æ³•
  //
  //  [A] é“è·¯ã®é€”ä¸­ã‹ã‚‰Tå­—è·¯: ä¸»è¦é“è·¯ã‚¨ãƒƒã‚¸ã‚’ä¸­é–“ãƒãƒ¼ãƒ‰ã§åˆ†å‰²ã—ã€
  //      ãã“ã‹ã‚‰å‚ç›´æ–¹å‘ã«æ”¯ç·šã‚’ä¼¸ã°ã™
  //  [B] æ—¢å­˜äº¤å·®ç‚¹ã‹ã‚‰æ–œã‚æ–¹å‘ã«ä¼¸ã°ã—ã€åˆ¥ã®äº¤å·®ç‚¹ã¸æ¥ç¶š
  // ================================================================

  // [A] é“è·¯é€”ä¸­ã‹ã‚‰Tå­—è·¯æ”¯ç·š
  // æ—¢å­˜mainã‚¨ãƒƒã‚¸ã®ã†ã¡ååˆ†é•·ã„ã‚‚ã®ã‚’é¸ã³ã€ä¸­é–“ã«åˆ†å²ç‚¹ã‚’ä½œã‚‹
  function splitEdgeAndBranch(){
    // ç¾æ™‚ç‚¹ã®mainã‚¨ãƒƒã‚¸ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼ˆåˆ†å‰²ä¸­ã«edgesãŒå¤‰åŒ–ã™ã‚‹ãŸã‚ï¼‰
    const mainEdges=edges.filter(e=>e.type==="main"&&e.length>180);
    // ãƒ©ãƒ³ãƒ€ãƒ ã«æ•°æœ¬é¸ã‚“ã§è©¦ã¿ã‚‹
    const targets=[...mainEdges].sort(()=>Math.random()-0.5).slice(0,4);

    for(const e of targets){
      if(Math.random()<0.4) continue; // 60%ã®ç¢ºç‡ã§è©¦ã¿ã‚‹

      // ä¸­é–“ç‚¹ã‚’25ã€œ75%ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
      const t=0.3+Math.random()*0.4;
      const mx=e.from.x+(e.to.x-e.from.x)*t;
      const my=e.from.y+(e.to.y-e.from.y)*t;

      // è¿‘ã™ãã‚‹æ—¢å­˜ãƒãƒ¼ãƒ‰ãŒã‚ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
      if(nodes.some(n=>n.type==="cross"&&Math.hypot(n.x-mx,n.y-my)<80)) continue;

      // ã‚¨ãƒƒã‚¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
      const vx=e.to.x-e.from.x, vy=e.to.y-e.from.y;
      const len=Math.hypot(vx,vy);
      // å‚ç›´æ–¹å‘ï¼ˆå·¦å³ã©ã¡ã‚‰ã‹ï¼‰
      const side=Math.random()<0.5?1:-1;
      const nx=-vy/len*side, ny=vx/len*side;
      const bLen=100+Math.random()*80;
      const tx=Math.max(30,Math.min(970, mx+nx*bLen));
      const ty=Math.max(30,Math.min(670, my+ny*bLen));

      // åˆ†å²ç‚¹ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
      const mid=mkNode(mx,my,"cross");

      // å…ƒã®ã‚¨ãƒƒã‚¸ã‚’åˆ†å‰²: fromâ†’mid ã¨ midâ†’to
      // å…ƒã‚¨ãƒƒã‚¸ã‚’å‰Šé™¤ã—ã¦2åˆ†å‰²
      const iFrom=edges.indexOf(e);
      const ePair=edges.find(ep=>ep.from===e.to&&ep.to===e.from);
      if(iFrom===-1) { nodes.splice(nodes.indexOf(mid),1); continue; }
      edges.splice(iFrom,1);
      if(ePair) edges.splice(edges.indexOf(ePair),1);

      // åˆ†å‰²ã‚¨ãƒƒã‚¸è¿½åŠ ï¼ˆcanAddä¸è¦: å…ƒã‚¨ãƒƒã‚¸ã®éƒ¨åˆ†ãªã®ã§äº¤å·®ãªã—ï¼‰
      edges.push(new Edge(e.from,mid,"main"));
      edges.push(new Edge(mid,e.from,"main"));
      edges.push(new Edge(mid,e.to,"main"));
      edges.push(new Edge(e.to,mid,"main"));

      // æ”¯ç·šæœ«ç«¯ãƒãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦è¿½åŠ 
      const term=mkNode(tx,ty,"cross");
      if(canAdd(mid,term,60)){
        edges.push(new Edge(mid,term,"branch"));
        edges.push(new Edge(term,mid,"branch"));
        // æœ«ç«¯ã‹ã‚‰ã•ã‚‰ã«è¿‘éš£äº¤å·®ç‚¹ã¸æ¥ç¶šã§ãã‚Œã°é€šã‚ŠæŠœã‘ã«
        const allC=nodes.filter(n=>n.type==="cross"&&!n.external&&n!==mid&&n!==term);
        const nb=allC
          .filter(m=>Math.hypot(m.x-tx,m.y-ty)<200)
          .sort((a,b)=>Math.hypot(a.x-tx,a.y-ty)-Math.hypot(b.x-tx,b.y-ty))[0];
        if(nb&&canAdd(term,nb,50)) addPair(term,nb,"branch");
      } else {
        nodes.splice(nodes.indexOf(term),1);
      }
    }
  }
  splitEdgeAndBranch();

  // [B] æ—¢å­˜äº¤å·®ç‚¹ã‹ã‚‰æ”¯ç·šã‚’ä¼¸ã°ã™ï¼ˆsplitEdgeAndBranchå¾Œã«å†å–å¾—ã—ã¦æ–°ãƒãƒ¼ãƒ‰ã‚‚å«ã‚ã‚‹ï¼‰
  const allCross=nodes.filter(n=>n.type==="cross"&&!n.external);

  function existingAngles(node){
    return edges.filter(e=>e.from===node)
      .map(e=>Math.atan2(e.to.y-node.y,e.to.x-node.x));
  }
  function angleFarEnough(angle,existing){
    return existing.every(a=>{
      let d=Math.abs(angle-a)%(2*Math.PI);
      if(d>Math.PI) d=2*Math.PI-d;
      return d>Math.PI/12; // 15åº¦ä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚Œã°å¯
    });
  }

  for(const n of allCross){
    if(edges.some(e=>e.from===n&&e.type==="branch")) continue;
    if(Math.random()<0.5) continue; // 50%ã§è©¦ã¿ã‚‹
    const exAngles=existingAngles(n);
    const bLen=100+Math.random()*100;
    const angles=Array.from({length:16},(_,i)=>i*(Math.PI/8)).sort(()=>Math.random()-0.5);

    for(const angle of angles){
      if(!angleFarEnough(angle,exAngles)) continue;
      const tx=Math.max(30,Math.min(970, n.x+Math.cos(angle)*bLen));
      const ty=Math.max(30,Math.min(670, n.y+Math.sin(angle)*bLen));

      // è¿‘ãã«æ—¢å­˜äº¤å·®ç‚¹ãŒã‚ã‚Œã°ãã“ã¸æ¥ç¶šï¼ˆé€šã‚ŠæŠœã‘ï¼‰
      const snap=allCross.find(m=>m!==n&&Math.hypot(m.x-tx,m.y-ty)<80);
      if(snap){ if(addPair(n,snap,"branch")) break; continue; }

      const term=mkNode(tx,ty,"cross");
      if(canAdd(n,term,80)){
        edges.push(new Edge(n,term,"branch"));
        edges.push(new Edge(term,n,"branch"));
        // æœ«ç«¯ã‹ã‚‰ã‚‚åˆ¥äº¤å·®ç‚¹ã¸ç¹‹ã’ã‚‹ã‹è©¦ã¿ã‚‹
        const nb=allCross
          .filter(m=>m!==n&&Math.hypot(m.x-tx,m.y-ty)<200)
          .sort((a,b)=>Math.hypot(a.x-tx,a.y-ty)-Math.hypot(b.x-tx,b.y-ty))[0];
        if(nb&&canAdd(term,nb,50)) addPair(term,nb,"branch");
        break;
      } else {
        nodes.splice(nodes.indexOf(term),1);
      }
    }
  }

  // ================================================================
  // [C] æ”¯ç·šã®ä¸€éƒ¨ã‚’onewayã«å¤‰æ›ï¼ˆç´„30%ï¼‰
  // onewayã¯é€†å‘ãã‚¨ãƒƒã‚¸ã‚’æŒãŸãªã„çœŸã®ä¸€æ–¹é€šè¡Œã€‚
  // å¯¾è±¡: branchå‹ã‚¨ãƒƒã‚¸ã®ãƒšã‚¢ã®ã†ã¡ã€ãƒ©ãƒ³ãƒ€ãƒ ã«ç‰‡æ–¹ã‚’å‰Šé™¤ã—ã¦onewayã«ã™ã‚‹
  {
    // branchã‚¨ãƒƒã‚¸ã‚’ãƒšã‚¢å˜ä½ã§å–å¾—ï¼ˆAâ†’B ã¨ Bâ†’A ã®çµ„ï¼‰
    const branchPairs=new Set();
    const toRemove=[];
    for(const e of edges){
      if(e.type!=="branch") continue;
      const key=[e.from,e.to].map(n=>nodes.indexOf(n)).sort().join("-");
      if(branchPairs.has(key)) continue;
      branchPairs.add(key);
      // å¤–éƒ¨ãƒãƒ¼ãƒ‰ãŒçµ¡ã‚€ã‚¨ãƒƒã‚¸ã¯onewayä¸å¯ï¼ˆé€²å…¥ãƒ»é€€å‡ºãŒå£Šã‚Œã‚‹ï¼‰
      if(e.from.external||e.to.external) continue;
      if(Math.random()<0.30){
        // ã“ã®ãƒšã‚¢ã‚’onewayã«: é€†å‘ãã‚¨ãƒƒã‚¸ã‚’å‰Šé™¤ã—ã¦æ®‹ã‚Šã‚’onewayã«å¤‰æ›´
        const rev=edges.find(r=>r.from===e.to&&r.to===e.from&&r.type==="branch");
        if(rev){
          toRemove.push(rev);
          e.type="oneway";
        }
      }
    }
    for(const r of toRemove) edges.splice(edges.indexOf(r),1);
  }

  // ================================================================
  // [D] å¤–éƒ¨ãƒãƒ¼ãƒ‰ã¸ã®è¿½åŠ æ¥ç¶š
  // ----------------------------------------------------------------
  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ã”ã¨ã«ã€ä»¥ä¸‹ã®3ã‚¿ã‚¤ãƒ—ã‚’ãƒãƒ©ãƒ³ã‚¹ã‚ˆãè¿½åŠ æ¥ç¶šã™ã‚‹ã€‚
  //  - "main"  (2è»Šç·šåŒæ–¹å‘): 35%
  //  - "branch"(1è»Šç·šåŒæ–¹å‘): 35%
  //  - "oneway"(1è»Šç·šä¸€æ–¹å‘): 30%
  //
  // â˜… ãƒã‚°ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ:
  //   å¤–éƒ¨ãƒãƒ¼ãƒ‰(x=0, x=1000, y=0, y=700)ã‹ã‚‰å†…éƒ¨äº¤å·®ç‚¹ã¸ã®ç·šåˆ†ã¯
  //   å¿…ãšæ—¢å­˜å¹¹ç·šã‚¨ãƒƒã‚¸ã¨äº¤å·®ã™ã‚‹ãŸã‚ã€é€šå¸¸ã® canAdd() ã§ã¯å…¨ã¦å¼¾ã‹ã‚Œã‚‹ã€‚
  //   â†’ å¤–éƒ¨ãƒãƒ¼ãƒ‰å°‚ç”¨ã® canAddExt() ã‚’ä½¿ç”¨:
  //      é‡è¤‡ãƒã‚§ãƒƒã‚¯ã®ã¿è¡Œã„ã€äº¤å·®ãƒ»è¿‘æ¥å¹³è¡Œãƒã‚§ãƒƒã‚¯ã¯çœç•¥ã™ã‚‹ã€‚
  //      ãŸã ã—åŒä¸€æ–¹å‘ã«æ—¢ã«ã‚¨ãƒƒã‚¸ãŒã‚ã‚‹å ´åˆï¼ˆä¸¦èµ°ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—ã€‚
  {
    // å¤–éƒ¨ãƒãƒ¼ãƒ‰å°‚ç”¨ãƒã‚§ãƒƒã‚¯ï¼ˆäº¤å·®ãƒ»è¿‘æ¥å¹³è¡Œãƒã‚§ãƒƒã‚¯ãªã—ï¼‰
    function canAddExt(a, b, minLen=50){
      if(Math.hypot(b.x-a.x,b.y-a.y) < minLen) return false;
      // é‡è¤‡ãƒã‚§ãƒƒã‚¯: åŒä¸€ãƒšã‚¢é–“ã«æ—¢ã«ã‚¨ãƒƒã‚¸ãŒã‚ã‚Œã°NG
      if(edges.some(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a))) return false;
      // è¿‘æ¥å¹³è¡Œãƒã‚§ãƒƒã‚¯ã®ã¿ï¼ˆåŒã˜ä½ç½®ã®ä¸¦èµ°é“è·¯ã¯é˜²ãï¼‰
      const vx=b.x-a.x, vy=b.y-a.y, vl=Math.hypot(vx,vy);
      for(const e of edges){
        const ex=e.to.x-e.from.x, ey=e.to.y-e.from.y, el=Math.hypot(ex,ey);
        if(el<1) continue;
        if(Math.abs((vx*ex+vy*ey)/(vl*el)) < 0.90) continue;
        const near=[0.4,0.6].some(t=>{
          const px=a.x+vx*t, py=a.y+vy*t;
          return ptSegDist({x:px,y:py},e.from,e.to)<30;
        });
        if(near) return false;
      }
      return true;
    }

    function addPairExt(a, b, type){
      if(!canAddExt(a,b)) return false;
      edges.push(new Edge(a,b,type));
      edges.push(new Edge(b,a,type));
      return true;
    }

    const extList = nodes.filter(n => n.external && n.type === "cross");
    const intList = nodes.filter(n => n.type === "cross" && !n.external);

    for(const ext of extList){
      if(Math.random() < 0.40) continue; // 60%ã®å¤–éƒ¨ãƒãƒ¼ãƒ‰ã§è©¦ã¿ã‚‹

      // æ¥ç¶šã‚¿ã‚¤ãƒ—ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
      const roll = Math.random();
      const connType = roll < 0.35 ? "main" : roll < 0.70 ? "branch" : "oneway";

      // æ—¢ã«mainã§ç¹‹ãŒã£ã¦ã„ã‚‹äº¤å·®ç‚¹ã‚’é™¤ã„ãŸå€™è£œã‚’è·é›¢é †ã§ä¸¦ã¹ã‚‹
      const cands = intList
        .filter(n => {
          const d = Math.hypot(n.x-ext.x, n.y-ext.y);
          return d > 60 && d < 450;
        })
        .filter(n => {
          // æ—¢ã«ä½•ã‚‰ã‹ã®ã‚¨ãƒƒã‚¸ã§ç¹‹ãŒã£ã¦ã„ã‚‹ãƒšã‚¢ã¯ã‚¹ã‚­ãƒƒãƒ—
          return !edges.some(e =>
            (e.from===ext && e.to===n) || (e.from===n && e.to===ext)
          );
        })
        .sort((a,b) => Math.hypot(a.x-ext.x,a.y-ext.y) - Math.hypot(b.x-ext.x,b.y-ext.y));

      for(const cand of cands){
        if(connType === "oneway"){
          if(!canAddExt(ext, cand, 50)) continue;
          if(Math.random() < 0.5){
            edges.push(new Edge(ext,  cand, "oneway")); // é€²å…¥
          } else {
            edges.push(new Edge(cand, ext,  "oneway")); // é€€å‡º
          }
          break;
        } else {
          if(addPairExt(ext, cand, connType)) break;
        }
      }
    }
  }

  // ================================================================
  // 3. å»ºç‰©ãƒ»å…¬åœ’ï¼ˆè£…é£¾ï¼‰
  // ================================================================
  const drawnPairs=new Set();
  for(const e of edges){
    const key=[e.from,e.to].map(n=>`${Math.round(n.x)},${Math.round(n.y)}`).sort().join("|");
    if(drawnPairs.has(key)) continue;
    drawnPairs.add(key);
    if(Math.random()>0.4) continue;
    const t=0.2+Math.random()*0.6;
    const roadW=e.lanes*LANE_W;
    const side=(Math.random()<0.5?1:-1)*(roadW+14+Math.random()*10);
    const vx=e.to.x-e.from.x,vy=e.to.y-e.from.y;
    const len=Math.sqrt(vx*vx+vy*vy);
    const bx=e.from.x+vx*t+(-vy/len)*side;
    const by=e.from.y+vy*t+(vx/len)*side;
    if(bx<10||bx>990||by<10||by>690) continue;
    const type=Math.random()<0.8?"house":"park";
    const img=type==="house"
      ?houseImgs[Math.floor(Math.random()*houseImgs.length)]
      :parkImg;
    nodes.push(new Node(bx,by,type,false,img));
  }

  // ================================================================
  // 3b. é§è»Šå ´ã®é…ç½®
  // ================================================================
  // é…ç½®ãƒ«ãƒ¼ãƒ«:
  //  - å…¨ã‚¨ãƒƒã‚¸(mainå«ã‚€)ã‹ã‚‰å€™è£œã‚’é¸ã¶ãŒã€é“è·¯å¹…ã‚’æ­£ç¢ºã«è€ƒæ…®ã—ãŸè·é›¢ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆ
  //  - é§è»Šå ´ä¸­å¿ƒ(30pxåŠå¾„)ãŒå…¨æ—¢å­˜ã‚¨ãƒƒã‚¸ã‹ã‚‰ç¢ºå®Ÿã«é›¢ã‚Œã¦ã„ã‚‹ã‹æ¤œè¨¼ã—ã¦ã‹ã‚‰é…ç½®
  //  - æ—¢å­˜ãƒãƒ¼ãƒ‰ãƒ»ä»–ã®é§è»Šå ´ã¨ã‚‚ååˆ†ãªé–“éš”ã‚’ç¢ºä¿
  {
    const parkingCount = 3 + Math.floor(Math.random()*4); // 3ã€œ6 ç®‡æ‰€
    const placedParking = [];
    const MIN_PARKING_DIST = 90; // é§è»Šå ´åŒå£«ãƒ»æ—¢å­˜ãƒãƒ¼ãƒ‰ã¨ã®æœ€å°è·é›¢
    const PARKING_RADIUS = 35;   // é§è»Šå ´ã®è¡¨ç¤ºåŠå¾„ï¼ˆ60pxç”»åƒã®åŠåˆ†+ä½™ç™½ï¼‰

    // å…¨ã‚¨ãƒƒã‚¸ã‹ã‚‰å€™è£œã‚’å–ã‚‹ï¼ˆmainã‚‚å«ã‚ã‚‹ï¼‰
    const candEdges = [...edges].sort(()=>Math.random()-0.5);

    for(const e of candEdges){
      if(placedParking.length >= parkingCount) break;
      if(e.from.external || e.to.external) continue; // å¤–éƒ¨ãƒãƒ¼ãƒ‰æ¥ç¶šã‚¨ãƒƒã‚¸ã¯é™¤å¤–

      const vx = e.to.x-e.from.x, vy = e.to.y-e.from.y;
      const len = Math.hypot(vx,vy);
      if(len < 80) continue;

      const t = 0.25 + Math.random()*0.5;  // ä¸­é–“éƒ¨åˆ†ã‹ã‚‰é¸ã¶
      const nx = -vy/len, ny = vx/len;     // ã‚¨ãƒƒã‚¸ã®æ³•ç·šï¼ˆå·¦å³æ–¹å‘ï¼‰

      // é“è·¯å¹…ã®åŠåˆ† + é§è»Šå ´åŠå¾„ + ä½™ç™½ = ç¢ºå®Ÿã«é“è·¯ã«é‡ãªã‚‰ãªã„è·é›¢
      const roadHalfW = e.lanes * LANE_W / 2;
      const safeOffset = roadHalfW + PARKING_RADIUS + 12; // ä½™ç™½12px

      for(const side of [1, -1]){
        const px = e.from.x + vx*t + nx*side*safeOffset;
        const py = e.from.y + vy*t + ny*side*safeOffset;

        // ç”»é¢å¤–ãƒã‚§ãƒƒã‚¯
        if(px < 40 || px > 960 || py < 40 || py > 660) continue;

        // å…¨ã‚¨ãƒƒã‚¸ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆé“è·¯å¹…+é§è»Šå ´åŠå¾„+ä½™ç™½ã‚ˆã‚Šè¿‘ã‘ã‚Œã°NGï¼‰
        const onRoad = edges.some(e2 => {
          const evx=e2.to.x-e2.from.x, evy=e2.to.y-e2.from.y, el=Math.hypot(evx,evy);
          if(el<1) return false;
          const et=Math.max(0,Math.min(1,((px-e2.from.x)*evx+(py-e2.from.y)*evy)/(el*el)));
          const dist=Math.hypot(px-(e2.from.x+evx*et), py-(e2.from.y+evy*et));
          return dist < e2.lanes*LANE_W/2 + PARKING_RADIUS + 8;
        });
        if(onRoad) continue;

        // æ—¢å­˜ãƒãƒ¼ãƒ‰ï¼ˆå…¨ã‚¿ã‚¤ãƒ—ï¼‰ã¨ã®è·é›¢ãƒã‚§ãƒƒã‚¯
        const tooClose = nodes.some(n => Math.hypot(n.x-px,n.y-py) < MIN_PARKING_DIST);
        if(tooClose) continue;

        // é…ç½®ç¢ºå®š
        const pNode = new Node(px, py, "parking", true, parkingImg);
        nodes.push(pNode);
        placedParking.push(pNode);

        // æœ€ã‚‚è¿‘ã„å†…éƒ¨äº¤å·®ç‚¹ã¨æ¥ç¶š
        const nearest = nodes
          .filter(n=>n.type==="cross"&&!n.external&&Math.hypot(n.x-px,n.y-py)<350)
          .sort((a,b)=>Math.hypot(a.x-px,a.y-py)-Math.hypot(b.x-px,b.y-py))[0];
        if(nearest && canAdd(pNode, nearest, 40)){
          edges.push(new Edge(pNode, nearest, "branch"));
          edges.push(new Edge(nearest, pNode, "branch"));
        }
        break; // ã“ã®ã‚¨ãƒƒã‚¸ã§ã¯1ã¤é…ç½®ã—ãŸã‚‰æ¬¡ã®ã‚¨ãƒƒã‚¸ã¸
      }
    }
  }

  // ================================================================
  // 4. å¤–éƒ¨ãƒãƒ¼ãƒ‰å­¤ç«‹ãƒã‚§ãƒƒã‚¯
  // ================================================================
  const extNodes=nodes.filter(n=>n.external);
  const intNodes=nodes.filter(n=>n.type==="cross"&&!n.external);
  for(const ext of extNodes){
    const hasOut=edges.some(e=>e.from===ext);
    const hasIn =edges.some(e=>e.to===ext);
    if(!hasOut||!hasIn){
      const nearest=intNodes.slice()
        .sort((a,b)=>Math.hypot(a.x-ext.x,a.y-ext.y)-Math.hypot(b.x-ext.x,b.y-ext.y))[0];
      if(nearest){
        if(!hasOut) edges.push(new Edge(ext,nearest,"branch"));
        if(!hasIn)  edges.push(new Edge(nearest,ext,"branch"));
      }
    }
  }

  // ================================================================
  // 5. å·ã®ç”Ÿæˆ
  // ================================================================
  // hYsï¼ˆæ°´å¹³å¹¹ç·šã®yåº§æ¨™ï¼‰ã®éš£æ¥ãƒšã‚¢é–“ã€ãŠã‚ˆã³
  // vXsï¼ˆå‚ç›´å¹¹ç·šã®xåº§æ¨™ï¼‰ã®éš£æ¥ãƒšã‚¢é–“ã‚’èª¿ã¹ã€
  // ã€Œå·ã¨ã—ã¦é©åˆ‡ãªæ¡ä»¶ã€ã‚’æº€ãŸã™å ´åˆã«ç¢ºç‡ã§å·ã‚’ç”Ÿæˆã™ã‚‹ã€‚
  //
  // å·ã¨ã—ã¦é©åˆ‡ãªæ¡ä»¶:
  //  â‘  2æœ¬ã®å¹³è¡Œå¹¹ç·šã®é–“éš”ãŒ 80ã€œ280pxï¼ˆåºƒã™ããšç‹­ã™ããšï¼‰
  //  â‘¡ ãã®å¸¯çŠ¶é ˜åŸŸã®å†…éƒ¨ã«äº¤å·®ç‚¹ãƒãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ãªã„
  //     ï¼ˆé“è·¯ãŒé€šã£ã¦ã„ãªã„ç©ºç™½åœ°å¸¯ï¼‰
  //  â‘¢ ç¢ºç‡ 60% ã§å‡ºç¾

  rivers.length = 0; // ãƒªã‚»ãƒƒãƒˆ

  const ROAD_HALF = 20; // é“è·¯ç«¯ã‹ã‚‰ã®ä½™ç™½ï¼ˆå·ã¯é“è·¯ã«è¢«ã‚‰ãªã„ï¼‰
  const RIVER_MIN = 80, RIVER_MAX = 280;

  // æ°´å¹³å¹¹ç·šãƒšã‚¢ â†’ æ¨ªå‘ãå·
  for(let i=0; i<hYs.length-1; i++){
    const y1 = hYs[i]   + ROAD_HALF;
    const y2 = hYs[i+1] - ROAD_HALF;
    const gap = y2 - y1;
    if(gap < RIVER_MIN || gap > RIVER_MAX) continue;
    // å¸¯ã®å†…éƒ¨ã«äº¤å·®ç‚¹ãŒå…¥ã‚Šè¾¼ã‚“ã§ã„ãªã„ã‹
    const blocked = nodes.some(n =>
      n.type === "cross" && !n.external &&
      n.y > hYs[i] + ROAD_HALF && n.y < hYs[i+1] - ROAD_HALF
    );
    if(blocked) continue;
    if(Math.random() < 0.85){
      rivers.push({ type:"h", y1, y2 });
    }
  }

  // å‚ç›´å¹¹ç·šãƒšã‚¢ â†’ ç¸¦å‘ãå·
  for(let i=0; i<vXs.length-1; i++){
    const x1 = vXs[i]   + ROAD_HALF;
    const x2 = vXs[i+1] - ROAD_HALF;
    const gap = x2 - x1;
    if(gap < RIVER_MIN || gap > RIVER_MAX) continue;
    const blocked = nodes.some(n =>
      n.type === "cross" && !n.external &&
      n.x > vXs[i] + ROAD_HALF && n.x < vXs[i+1] - ROAD_HALF
    );
    if(blocked) continue;
    if(Math.random() < 0.85){
      rivers.push({ type:"v", x1, x2 });
    }
  }

  // ================================================================
  // 6. åœ°å½¢ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆï¼ˆsinåˆæˆãƒã‚¤ã‚ºï¼‰
  // ================================================================
  // é“è·¯ãƒ»å·ãƒ»å»ºç‰©ã®ä¸‹ã«æ•·ãã€Œç©ºãåœ°ã€ã®åœ°å½¢ã‚’äº‹å‰ç”Ÿæˆã™ã‚‹ã€‚
  // sinæ³¢ã‚’è¤‡æ•°é‡ã­åˆã‚ã›ã¦ãƒ‘ãƒ¼ãƒªãƒ³ãƒã‚¤ã‚ºçš„ãªè‡ªç„¶ãªè‰²ã‚€ã‚‰ã‚’ä½œã‚‹ã€‚
  // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³Canvasã«æ›¸ãè¾¼ã¿ã€æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ drawImage 1å›ã§æç”»ã€‚
  {
    const W = 1000, H = 700;
    terrainCanvas = document.createElement("canvas");
    terrainCanvas.width  = W;
    terrainCanvas.height = H;
    const tCtx = terrainCanvas.getContext("2d");
    const imageData = tCtx.createImageData(W, H);
    const data = imageData.data;

    // ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰å€¤ï¼ˆãƒãƒƒãƒ—ã”ã¨ã«ç•°ãªã‚‹åœ°å½¢ï¼‰
    const sx = Math.random() * 500;
    const sy = Math.random() * 500;

    // sinåˆæˆãƒã‚¤ã‚º: è¤‡æ•°å‘¨æ³¢æ•°ãƒ»ä½ç›¸ã®sinæ³¢ã‚’é‡ã­ã¦è‡ªç„¶ãªãƒ ãƒ©ã‚’ä½œã‚‹
    function noise(x, y){
      const x0 = x + sx, y0 = y + sy;
      let v = 0;
      // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–1: å¤§ããªã†ã­ã‚Šï¼ˆåœ°å½¢ã®å¤§åŒºç”»ï¼‰
      v += Math.sin(x0 * 0.008 + y0 * 0.005) * 0.40;
      // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–2: ä¸­ç¨‹åº¦ã®ãƒ ãƒ©ï¼ˆåŒºç”»å†…ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰
      v += Math.sin(x0 * 0.022 + y0 * 0.019 + 1.3) * 0.25;
      // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–3: ç´°ã‹ã„ãƒ ãƒ©ï¼ˆè‰ã®ç”Ÿãˆå…·åˆï¼‰
      v += Math.sin(x0 * 0.055 + y0 * 0.048 + 2.7) * 0.15;
      // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–4: æ–œã‚æ–¹å‘ã®å¤‰åŒ–ï¼ˆè‡ªç„¶ã•ã‚’å¢—ã™ï¼‰
      v += Math.sin((x0 + y0) * 0.015 + 0.8) * 0.12;
      // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–5: é«˜å‘¨æ³¢ãƒã‚¤ã‚ºï¼ˆã–ã‚‰ã¤ãæ„Ÿï¼‰
      v += Math.sin(x0 * 0.11 + y0 * 0.09 + 4.1) * 0.08;
      // -1ã€œ+1 â†’ 0ã€œ1 ã«æ­£è¦åŒ–
      return (v + 1) * 0.5;
    }

    // åœ°å½¢ã‚¿ã‚¤ãƒ—ã‚’æ±ºå®šï¼ˆãƒã‚¤ã‚ºå€¤ã‹ã‚‰è‰²ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸ã¶ï¼‰
    // t=0.0ã€œ1.0 â†’ ä¹¾ç‡¥ã—ãŸåœŸ ã€œ è±Šã‹ãªè‰åœ°
    function terrainColor(t){
      // è¤‡æ•°ã®åœ°å½¢ã‚¿ã‚¤ãƒ—ã‚’é–¾å€¤ã§åˆ†é¡
      if(t < 0.20){
        // ä¹¾ã„ãŸåœŸãƒ»ç ‚åˆ©ï¼ˆæš—ã„èŒ¶ï¼‰
        const f = t / 0.20;
        return [
          Math.round(90  + f * 30),  // R
          Math.round(72  + f * 20),  // G
          Math.round(55  + f * 15),  // B
        ];
      } else if(t < 0.40){
        // è’åœ°ãƒ»ç ‚åœ°ï¼ˆé»„è¤è‰²ï¼‰
        const f = (t - 0.20) / 0.20;
        return [
          Math.round(120 + f * 25),
          Math.round(92  + f * 28),
          Math.round(60  + f * 10),
        ];
      } else if(t < 0.60){
        // è–„ã„è‰åœ°ï¼ˆãã™ã‚“ã ç·‘ï¼‰
        const f = (t - 0.40) / 0.20;
        return [
          Math.round(80  + f * (-10)),
          Math.round(100 + f * 20),
          Math.round(55  + f * 10),
        ];
      } else if(t < 0.80){
        // è‰åœ°ï¼ˆç·‘ï¼‰
        const f = (t - 0.60) / 0.20;
        return [
          Math.round(70  + f * (-10)),
          Math.round(120 + f * 20),
          Math.round(65  + f * 5),
        ];
      } else {
        // æ¿ƒã„è‰åœ°ï¼ˆæ·±ç·‘ï¼‰
        const f = (t - 0.80) / 0.20;
        return [
          Math.round(60  + f * (-5)),
          Math.round(140 + f * 10),
          Math.round(70  + f * 5),
        ];
      }
    }

    for(let y = 0; y < H; y++){
      for(let x = 0; x < W; x++){
        const t = noise(x, y);
        const [r, g, b] = terrainColor(t);
        const idx = (y * W + x) * 4;
        data[idx]   = r;
        data[idx+1] = g;
        data[idx+2] = b;
        data[idx+3] = 255;
      }
    }

    tCtx.putImageData(imageData, 0, 0);
  }
}


// ===== ã‚¹ã‚³ã‚¢æ›´æ–° =====
function updateScore(jamCount){
  // æ¸‹æ»ã‚¼ãƒ­ãªã‚‰é€£ç¶šãƒœãƒ¼ãƒŠã‚¹è“„ç©ã€æ¸‹æ»ãŒã‚ã‚Œã°ãƒªã‚»ãƒƒãƒˆ
  if(jamCount === 0){
    bonusStreak++;
    // 120ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„2ç§’ï¼‰ã”ã¨ã«ãƒœãƒ¼ãƒŠã‚¹å€ç‡UPï¼ˆæœ€å¤§5.0ï¼‰
    if(bonusStreak % 120 === 0) scoreBonus = Math.min(5.0, scoreBonus + 0.1);
  } else {
    bonusStreak = 0;
    scoreBonus  = Math.max(1.0, scoreBonus - 0.05);
    // æ¸‹æ»ä¸­ãƒšãƒŠãƒ«ãƒ†ã‚£: æ¸‹æ»1å°ã«ã¤ãæ¯ãƒ•ãƒ¬ãƒ¼ãƒ -0.5ç‚¹
    score = Math.max(0, score - jamCount * 0.5);
  }
  // äº‹æ•…ä¸­ã¯è¿½åŠ ãƒšãƒŠãƒ«ãƒ†ã‚£
  if(accidents.length > 0){
    score = Math.max(0, score - accidents.length * 2);
  }
  // ãƒ©ãƒ³ã‚¯åˆ¤å®š
  let rank="D", cls="rank-D";
  if(score>50000){rank="S";cls="rank-S";}
  else if(score>20000){rank="A";cls="rank-A";}
  else if(score>8000) {rank="B";cls="rank-B";}
  else if(score>2000) {rank="C";cls="rank-C";}
  const rv=document.getElementById("rankVal");
  rv.textContent=rank; rv.className=cls;
  document.getElementById("scoreVal").textContent=Math.floor(score).toLocaleString();
  document.getElementById("bonusVal").textContent=`BONUS Ã—${scoreBonus.toFixed(1)}`;
  document.getElementById("accVal").textContent=accidentCount;
}

// ===== äº‹æ•…ç™ºç”Ÿ =====
function triggerAccident(){
  // èµ°è¡Œä¸­ã®è»ŠãŒã‚ã‚‹ã‚¨ãƒƒã‚¸ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
  const activeEdges=edges.filter(e=>e.laneCars.some(lc=>lc.length>0));
  if(activeEdges.length===0) return;
  const e=activeEdges[Math.floor(Math.random()*activeEdges.length)];
  const t=0.3+Math.random()*0.4;
  const ax=e.from.x+(e.to.x-e.from.x)*t;
  const ay=e.from.y+(e.to.y-e.from.y)*t;
  // åŒã˜å ´æ‰€ã«é‡è¤‡ã—ãªã„ã‚ˆã†ã«ãƒã‚§ãƒƒã‚¯
  if(accidents.some(a=>Math.hypot(a.x-ax,a.y-ay)<60)) return;
  accidents.push({x:ax,y:ay,edge:e,timer:ACCIDENT_DURATION,maxTimer:ACCIDENT_DURATION,blink:0});
  accidentCount++;
  score=Math.max(0,score-500); // äº‹æ•…ç™ºç”ŸãƒšãƒŠãƒ«ãƒ†ã‚£ -500ç‚¹
}

// ===== äº‹æ•…æ›´æ–° =====
function updateAccidents(){
  for(let i=accidents.length-1;i>=0;i--){
    const a=accidents[i];
    a.timer--;
    a.blink++;
    if(a.timer<=0) accidents.splice(i,1);
  }
}

// ===== äº‹æ•…æç”» =====
function drawAccidents(){
  for(const a of accidents){
    const progress=a.timer/a.maxTimer; // 1.0â†’0.0
    // æ®‹ã‚Šæ™‚é–“ãŒå°‘ãªã„ã»ã©ç‚¹æ»…é€Ÿåº¦UP
    const blinkRate=Math.max(4,Math.floor(progress*20));
    const visible=(Math.floor(a.blink/blinkRate)%2===0);
    if(!visible) continue;

    ctx.save();
    ctx.translate(a.x,a.y);

    // äº‹æ•…ã®å½±éŸ¿åœã‚’åŠé€æ˜èµ¤ã§è¡¨ç¤º
    const alpha=0.15+0.15*Math.sin(a.blink*0.1);
    ctx.beginPath();
    ctx.arc(0,0,ACCIDENT_SLOWZONE,0,Math.PI*2);
    ctx.fillStyle=`rgba(255,60,0,${alpha})`;
    ctx.fill();

    // äº‹æ•…ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç‚+è­¦å‘Šï¼‰
    const sz=22+Math.sin(a.blink*0.15)*3; // è„ˆå‹•
    ctx.font=`${sz}px serif`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText("ğŸ’¥",0,0);

    // æ®‹ã‚Šæ™‚é–“ãƒãƒ¼
    const barW=40, barH=5;
    ctx.fillStyle="rgba(0,0,0,0.6)";
    ctx.fillRect(-barW/2,14,barW,barH);
    ctx.fillStyle=progress>0.5?"#f0a000":"#ff3030";
    ctx.fillRect(-barW/2,14,barW*progress,barH);

    ctx.restore();
  }
}

// ===== ç·Šæ€¥å¯¾å¿œï¼ˆã‚¯ãƒªãƒƒã‚¯ã§äº‹æ•…ã‚’å³æ™‚è§£æ¶ˆï¼‰=====
function clearAccident(){
  if(accidents.length===0){ alert("ç¾åœ¨ã€äº‹æ•…ã¯ç™ºç”Ÿã—ã¦ã„ã¾ã›ã‚“ã€‚"); return; }
  if(score<300){ alert("ã‚¹ã‚³ã‚¢ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆ300ç‚¹å¿…è¦ï¼‰ã€‚"); return; }
  score-=300;
  accidents.splice(0,1); // æœ€åˆã®äº‹æ•…ã‚’è§£æ¶ˆ
}

// äº‹æ•…ã‚¯ãƒªãƒƒã‚¯æ¤œå‡ºï¼ˆcanvasä¸Šã®äº‹æ•…ã‚¢ã‚¤ã‚³ãƒ³ã‚¯ãƒªãƒƒã‚¯ï¼‰
canvas.addEventListener("click", ev=>{
  const r=canvas.getBoundingClientRect();
  const mx=ev.clientX-r.left, my=ev.clientY-r.top;
  // äº¤å·®ç‚¹ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã¯æ—¢å­˜ã®ã¾ã¾
  // äº‹æ•…ã‚¢ã‚¤ã‚³ãƒ³ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
  for(let i=accidents.length-1;i>=0;i--){
    const a=accidents[i];
    if(Math.hypot(mx-a.x,my-a.y)<30){
      if(score>=300){
        score-=300;
        accidents.splice(i,1);
        document.getElementById("scoreVal").textContent=Math.floor(score).toLocaleString();
      } else {
        // ã‚¹ã‚³ã‚¢ä¸è¶³ã‚’ç‚¹æ»…ã§ç¤ºã™
        const sv=document.getElementById("scoreVal");
        sv.style.color="#ff4040";
        setTimeout(()=>sv.style.color="#f0c040",500);
      }
      return;
    }
  }
});

// ===== BFSãƒ«ãƒ¼ãƒˆç”Ÿæˆ =====
// targetNodes: åˆ°é”ç›®æ¨™ãƒãƒ¼ãƒ‰ã®é…åˆ—ï¼ˆå‘¼ã³å‡ºã—å´ã§æŒ‡å®šï¼‰
function generateRouteBFS(startNode, targetNodes){
  const targets = targetNodes.filter(n => n !== startNode);
  if(targets.length === 0) return null;

  const queue = [{ node: startNode, path: [] }];
  const visited = new Set([startNode]);

  while (queue.length > 0) {
    const { node, path } = queue.shift();
    if (targets.includes(node) && path.length > 0) return path;

    for (const e of edges) {
      if (e.from !== node || visited.has(e.to)) continue;
      visited.add(e.to);
      const lane = selectLane(e);
      queue.push({ node: e.to, path: [...path, { edge: e, lane }] });
    }
  }
  return null;
}

// ===== è»Šç·šé¸æŠ =====
function selectLane(edge){
  let min = Infinity, chosen = 0;
  for (let i = 0; i < edge.lanes; i++) {
    if (edge.laneCars[i].length < min) { min = edge.laneCars[i].length; chosen = i; }
  }
  return chosen;
}

// æ”¯ç·šæœ«ç«¯ãƒãƒ¼ãƒ‰: å…¨æ¥ç¶šã‚¨ãƒƒã‚¸ãŒbranchã®ã¿ã®ãƒãƒ¼ãƒ‰ï¼ˆç´”ç²‹ãªæã®å…ˆç«¯ï¼‰
function getBranchTerminals(){
  return nodes.filter(n => {
    if(n.external || n.type !== "cross") return false;
    const conn = edges.filter(e => e.from === n || e.to === n);
    return conn.length > 0 && conn.every(e => e.type === "branch" || e.type === "oneway");
  });
}

// ===== è»Šç”Ÿæˆ =====
function spawnCar(){
  // ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹: å¤–éƒ¨ãƒãƒ¼ãƒ‰ + é§è»Šå ´ãƒãƒ¼ãƒ‰
  const spawnNodes = nodes.filter(n => n.external); // parking(external=true) ã‚‚å«ã‚€
  if(spawnNodes.length === 0) return;
  const start = spawnNodes[Math.floor(Math.random() * spawnNodes.length)];
  const img = carImgs[Math.floor(Math.random() * carImgs.length)];

  // ç›®çš„åœ°ã®å„ªå…ˆåº¦:
  //  35%: é§è»Šå ´ã‚’ç›®çš„åœ°ã«ï¼ˆé§è»Šå ´â†’é§è»Šå ´ or å¤–éƒ¨â†’é§è»Šå ´ï¼‰
  //  25%: æ”¯ç·šæœ«ç«¯ã‚’ç›®çš„åœ°ã«
  //  40%: å¤–éƒ¨ãƒãƒ¼ãƒ‰â†’å¤–éƒ¨ãƒãƒ¼ãƒ‰ï¼ˆé€šå¸¸ï¼‰
  const rand = Math.random();

  if(rand < 0.35){
    // é§è»Šå ´ã‚’ç›®çš„åœ°ã«
    const parkings = nodes.filter(n => n.type==="parking" && n !== start);
    if(parkings.length > 0){
      const shuffled = [...parkings].sort(() => Math.random() - 0.5);
      for(const goal of shuffled){
        const route = generateRouteBFS(start, [goal]);
        if(route && route.length > 0){
          cars.push(new Car(route, img));
          return;
        }
      }
    }
  } else if(rand < 0.60){
    // æ”¯ç·šæœ«ç«¯ã‚’ç›®çš„åœ°ã«
    const terminals = getBranchTerminals();
    if(terminals.length > 0){
      const shuffled = [...terminals].sort(() => Math.random() - 0.5);
      for(const goal of shuffled){
        const route = generateRouteBFS(start, [goal]);
        if(route && route.length > 0){
          cars.push(new Car(route, img));
          return;
        }
      }
    }
  }

  // é€šå¸¸: å¤–éƒ¨ãƒãƒ¼ãƒ‰â†’å¤–éƒ¨ãƒãƒ¼ãƒ‰ï¼ˆé§è»Šå ´ä»¥å¤–ï¼‰
  const extOnly = nodes.filter(n => n.external && n.type !== "parking" && n !== start);
  const route = generateRouteBFS(start, extOnly.length>0 ? extOnly : spawnNodes);
  if(!route || route.length === 0) return;
  cars.push(new Car(route, img));
}

// ===== æ™‚é–“æ›´æ–° =====
function updateTime(){
  timeCounter++;
  const t=timeCounter%3600;
  let rate=0.02;
  if(t<800||(t>1800&&t<2600)) rate=0.08;
  else if(t>3000) rate=0.01;
  if(Math.random()<rate*flowRate*2) spawnCar();
  document.getElementById("timeLabel").textContent=
    (t<800||(t>1800&&t<2600))?"Rush":(t>3000?"Night":"Day");
}

// ===== é“è·¯æç”» =====
// å„ã‚¨ãƒƒã‚¸ã¯ä¸€æ–¹é€šè¡Œã€‚è»Šã¯é€²è¡Œå·¦å´(nxè² æ–¹å‘)ã‚’èµ°ã‚‹ã€‚
// é“è·¯ã‚’ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã§ y=0~-roadW ã®ç¯„å›²ã«æã(è² yå´=å·¦å´)ã€‚
// oneway: douro_small.png (67Ã—67px) ã‚’ä½¿ç”¨ã€1è»Šç·šå¹…ã€é€†å‘ãã‚¨ãƒƒã‚¸ãªã—
function drawRoad(e){
  const dx=e.to.x-e.from.x, dy=e.to.y-e.from.y;
  const dist=Math.sqrt(dx*dx+dy*dy);
  const angle=Math.atan2(dy,dx);
  const roadW=e.lanes*LANE_W;

  ctx.save();
  ctx.translate(e.from.x, e.from.y);
  ctx.rotate(angle);

  // é“è·¯é¢(é€²è¡Œå·¦å´ = ãƒ­ãƒ¼ã‚«ãƒ«yè² æ–¹å‘)
  ctx.fillStyle= e.type==="oneway" ? "#4a4a5a" : "#555";
  ctx.fillRect(0,-roadW,dist,roadW);

  if(e.type==="oneway"){
    // douro_small.png: 67Ã—67px ã‚’ã‚¿ã‚¤ãƒ«ã—ã¦æç”»ï¼ˆé“è·¯å¹…ã«åˆã‚ã›ã¦æ‹¡ç¸®ï¼‰
    if(onewayImg.complete&&onewayImg.naturalWidth>0){
      const tileW=67;
      let x=0;
      while(x<dist){
        ctx.drawImage(onewayImg, x, -roadW, tileW, roadW);
        x+=tileW;
      }
    }
    // ä¸€æ–¹é€šè¡ŒçŸ¢å°ã‚’ä¸­å¤®ã«æç”»ï¼ˆ20pxã”ã¨ã«çŸ¢å°è¨˜å·ï¼‰
    ctx.fillStyle="rgba(255,255,100,0.8)";
    ctx.font=`bold ${Math.max(10,roadW-4)}px sans-serif`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    const arrowStep=80;
    for(let x=arrowStep/2; x<dist; x+=arrowStep){
      ctx.fillText("â–¶", x, -roadW/2);
    }
  } else {
    if(roadImg.complete&&roadImg.naturalWidth>0){
      let x=0; while(x<dist){ ctx.drawImage(roadImg,x,-roadW,60,roadW); x+=60; }
    }
    // è»Šç·šç™½ç·š
    ctx.strokeStyle="rgba(255,255,255,0.6)";
    ctx.setLineDash([10,8]);
    ctx.lineWidth=1.5;
    for(let ln=1;ln<e.lanes;ln++){
      ctx.beginPath(); ctx.moveTo(0,-ln*LANE_W); ctx.lineTo(dist,-ln*LANE_W); ctx.stroke();
    }
    ctx.setLineDash([]);
  }
  ctx.restore();
}

// ===== UI =====
document.getElementById("flowSlider").oninput=function(){
  flowRate=parseInt(this.value)/100;
  document.getElementById("flowVal").textContent=this.value;
};
document.getElementById("greenSlider").oninput=function(){
  if(selectedNode){
    selectedNode.greenDuration=parseInt(this.value);
    document.getElementById("greenVal").textContent=selectedNode.greenDuration;
  }
};
canvas.onclick=ev=>{
  const r=canvas.getBoundingClientRect();
  const mx=ev.clientX-r.left, my=ev.clientY-r.top;
  for(const n of nodes){
    if(!n.external&&n.type==="cross"&&Math.abs(mx-n.x)<15&&Math.abs(my-n.y)<15){
      selectedNode=n;
      document.getElementById("greenSlider").value=n.greenDuration;
      document.getElementById("greenVal").textContent=n.greenDuration;
    }
  }
};

// ===== å·æç”» =====
function drawRivers(){
  for(const r of rivers){
    if(r.type==="h"){
      // ---- æ°´å¹³å· ----
      const w = 1000, h = r.y2 - r.y1;
      if(riverImg.complete && riverImg.naturalWidth > 0){
        // ç”»åƒã‚’æ¨ªã«ã‚¿ã‚¤ãƒ«ï¼ˆãã®ã¾ã¾æç”»ã€å›è»¢ãªã—ï¼‰
        const tw = 128;
        for(let x = 0; x < w; x += tw){
          ctx.drawImage(riverImg, x, r.y1, Math.min(tw, w - x), h);
        }
      } else {
        const grad = ctx.createLinearGradient(0, r.y1, 0, r.y2);
        grad.addColorStop(0,   "#4a9fc7");
        grad.addColorStop(0.3, "#2e86c1");
        grad.addColorStop(0.7, "#2e86c1");
        grad.addColorStop(1,   "#4a9fc7");
        ctx.fillStyle = grad;
        ctx.fillRect(0, r.y1, w, h);
      }
      // æ¨ªæ–¹å‘ã®æ³¢ç´‹ãƒ©ã‚¤ãƒ³
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1.5;
      const hStep = Math.max(10, h / 4);
      for(let y = r.y1 + hStep * 0.5; y < r.y2; y += hStep){
        ctx.beginPath();
        for(let x = 0; x <= 1000; x += 8){
          const wave = Math.sin((x * 0.05) + timeCounter * 0.04) * 2.5;
          x === 0 ? ctx.moveTo(x, y + wave) : ctx.lineTo(x, y + wave);
        }
        ctx.stroke();
      }

    } else {
      // ---- ç¸¦å· ----
      // å›è»¢ã¯ä½¿ã‚ãšã€ç¸¦æ–¹å‘ã«ã‚¿ã‚¤ãƒ«ã‚’ç©ã¿ä¸Šã’ã‚‹ã ã‘
      const cw = r.x2 - r.x1, ch = 700;
      if(riverImg.complete && riverImg.naturalWidth > 0){
        // ç¸¦ã«ã‚¿ã‚¤ãƒ«ã‚’ä¸¦ã¹ã‚‹ï¼ˆç”»åƒã®é«˜ã•128pxã‚’å·å¹…ã«æ‹¡ç¸®ã—ã¦ç©ã‚€ï¼‰
        const th = 128;
        for(let y = 0; y < ch; y += th){
          ctx.drawImage(riverImg, r.x1, y, cw, Math.min(th, ch - y));
        }
      } else {
        const grad = ctx.createLinearGradient(r.x1, 0, r.x2, 0);
        grad.addColorStop(0,   "#4a9fc7");
        grad.addColorStop(0.3, "#2e86c1");
        grad.addColorStop(0.7, "#2e86c1");
        grad.addColorStop(1,   "#4a9fc7");
        ctx.fillStyle = grad;
        ctx.fillRect(r.x1, 0, cw, ch);
      }
      // ç¸¦æ–¹å‘ã®æ³¢ç´‹ãƒ©ã‚¤ãƒ³
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1.5;
      const vStep = Math.max(10, cw / 4);
      for(let x = r.x1 + vStep * 0.5; x < r.x2; x += vStep){
        ctx.beginPath();
        for(let y = 0; y <= 700; y += 8){
          const wave = Math.sin((y * 0.05) + timeCounter * 0.04) * 2.5;
          y === 0 ? ctx.moveTo(x + wave, y) : ctx.lineTo(x + wave, y);
        }
        ctx.stroke();
      }
    }
  }
}

// ===== åœ°å½¢æç”» =====
function drawTerrain(){
  if(terrainCanvas){
    ctx.drawImage(terrainCanvas, 0, 0);
  }
}

// ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
// äº‹æ•…ç™ºç”Ÿã‚¿ã‚¤ãƒãƒ¼ï¼ˆå¹³å‡120ç§’ã«1å› = 7200ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
let nextAccidentIn = 3600 + Math.floor(Math.random()*3600);

function loop(){
  ctx.clearRect(0,0,1000,700);
  updateTime();
  nodes.forEach(n=>n.update());

  // äº‹æ•…ç™ºç”Ÿã‚¿ã‚¤ãƒãƒ¼
  nextAccidentIn--;
  if(nextAccidentIn<=0 && cars.length>3){
    triggerAccident();
    nextAccidentIn=3600+Math.floor(Math.random()*3600); // æ¬¡ã®äº‹æ•…ã¾ã§60ã€œ120ç§’
  }
  updateAccidents();

  drawTerrain();          // â‘  åœ°å½¢ï¼ˆæœ€èƒŒé¢ï¼‰
  drawRivers();           // â‘¡ å·
  edges.forEach(e=>drawRoad(e)); // â‘¢ é“è·¯
  for(const c of cars) c.update();
  for(let i=cars.length-1;i>=0;i--) if(!cars[i].alive) cars.splice(i,1);
  let jam=0;
  for(const c of cars){ c.draw(); if(c.wait>60) jam++; }
  drawAccidents();        // â‘£ äº‹æ•…ãƒãƒ¼ã‚«ãƒ¼ï¼ˆè»Šãƒ»ãƒãƒ¼ãƒ‰ã®ä¸Šï¼‰
  nodes.forEach(n=>n.draw());
  document.getElementById("jam").textContent=jam;
  updateScore(jam);
  requestAnimationFrame(loop);
}

// ===== ç”»åƒãƒ­ãƒ¼ãƒ‰ =====
function waitForImages(imgs,cb){
  let rem=imgs.length; if(rem===0){cb();return;}
  let done=false;
  const tick=()=>{ if(--rem<=0&&!done){done=true;cb();} };
  for(const img of imgs){ if(img.complete) tick(); else{ img.onload=tick; img.onerror=tick; } }
}
const allImgs=[roadImg,onewayImg,parkImg,parkingImg,riverImg,sigGreenImg,sigRedImg,...carImgs,...houseImgs];
waitForImages(allImgs,()=>{ generateCity(); loop(); console.log("âœ… v21 èµ·å‹•"); });
setTimeout(()=>{ if(!timeCounter){ generateCity(); loop(); console.warn("âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯"); } },5000);
</script>
</body>
</html>
