<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>éƒ½å¸‚äº¤é€šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ v19 å®‰å®šç‰ˆ</title>
<style>
body { margin:0; background:#1e1e1e; color:white; font-family:sans-serif;}
#ui { padding:8px; text-align:center;}
canvas { background:#2b2b2b; display:block; margin:auto;}
input { width:200px; }
</style>
</head>
<body>
<div id="ui">
æµå…¥é‡: <input type="range" id="flowSlider" min="0" max="100" value="50"><span id="flowVal">50</span>
|
äº¤å·®ç‚¹é’æ™‚é–“: <input type="range" id="greenSlider" min="60" max="300" value="120"><span id="greenVal">120</span>
|
æ™‚é–“å¸¯: <span id="timeLabel">Day</span>
|
æ¸‹æ»: <span id="jam">0</span>
</div>

<canvas id="game" width="1000" height="700"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nodes = [], edges = [], cars = [];
let selectedNode = null, timeCounter = 0, flowRate = 0.5;
const MIN_GAP = 20, SLOW_GAP = 60;
const laneWidth = 18;

// ===== ç”»åƒ =====
const roadImg = new Image(); roadImg.src = "douro.png";
const carImgs = []; for(let i=1;i<=10;i++){ const img=new Image(); img.src="car"+i+".png"; carImgs.push(img); }
const houseImgs = []; for(let i=1;i<=8;i++){ const img=new Image(); img.src="house"+i+".png"; houseImgs.push(img); }
const parkImg = new Image(); parkImg.src="park1.png";

// ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
function shuffleArray(array){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } }
function linesIntersect(p1,p2,p3,p4){ 
    const ccw=(a,b,c)=> (c.y-a.y)*(b.x-a.x) > (b.y-a.y)*(c.x-a.x);
    return (ccw(p1,p3,p4)!==ccw(p2,p3,p4)) && (ccw(p1,p2,p3)!==ccw(p1,p2,p4));
}

// ===== ã‚¨ãƒƒã‚¸è¿½åŠ  =====
function addEdgeSafe(a,b,type="branch"){
    for(const e of edges){
        if(a===e.from || a===e.to || b===e.from || b===e.to) continue;
        if(linesIntersect(a,b,e.from,e.to)) return false;
    }
    edges.push(new Edge(a,b,type));
    return true;
}

// ===== Node =====
class Node{
  constructor(x,y,type="cross",external=false,img=null){
    this.x=x; this.y=y; this.type=type; this.external=external;
    this.phase=0; this.timer=0; this.greenDuration=120;
    this.img=img;
  }
  update(){
    if(this.external || this.type!=="cross") return;
    this.timer++;
    if(this.timer>=this.greenDuration){ this.phase=(this.phase+1)%2; this.timer=0; }
  }
  draw(){
    switch(this.type){
      case "cross":
        ctx.fillStyle=this.external?"#444":"#666";
        ctx.fillRect(this.x-15,this.y-15,30,30);
        if(!this.external){
          ["up","down","left","right"].forEach(dir=>{
            const hasRoad={
              up: edges.some(e=>e.from===this && e.to.y<this.y),
              down: edges.some(e=>e.from===this && e.to.y>this.y),
              left: edges.some(e=>e.from===this && e.to.x<this.x),
              right: edges.some(e=>e.from===this && e.to.x>this.x)
            };
            if(!hasRoad[dir]) return;
            ctx.fillStyle=(this.phase===0 && (dir==="up"||dir==="down")) || (this.phase===1 && (dir==="left"||dir==="right"))?"#0f0":"#f00";
            switch(dir){
              case "up": ctx.fillRect(this.x-5,this.y-20,10,8); break;
              case "down": ctx.fillRect(this.x-5,this.y+12,10,8); break;
              case "left": ctx.fillRect(this.x-20,this.y-5,8,10); break;
              case "right": ctx.fillRect(this.x+12,this.y-5,8,10); break;
            }
          });
        }
        break;
      case "house":
      case "park":
        if(this.img) ctx.drawImage(this.img,this.x-20,this.y-20,40,40);
        break;
    }
  }
}

// ===== Edge =====
class Edge{
  constructor(from,to,type="branch"){
    this.from=from; this.to=to; this.type=type;
    // ä¸»è¦é“è·¯ã¯forward/backward å„2è»Šç·šã€æ”¯ç·šã¯å„1è»Šç·š
    this.lanesPerDir = (type==="main")? 2 : 1;
    this.length=Math.hypot(to.x-from.x,to.y-from.y);
    // laneCars ã¯ forward/backward é…åˆ—ã§ç®¡ç†
    this.laneCars={ forward:Array.from({length:this.lanesPerDir},()=>[]), backward:Array.from({length:this.lanesPerDir},()=>[]) };
  }
}

// ===== Car =====
let carCounter = 0;
class Car{
  constructor(route,img){
    this.idx = carCounter++;
    this.route=route;
    this.edgeIndex=0;
    this.edge=this.route[0].edge;
    this.edgeDir=this.route[0].dir;

    // ğŸš¦ å‹•çš„ã«ç©ºããƒ¬ãƒ¼ãƒ³ã‹ã‚‰é¸æŠ
    this.lane = this.selectLane(this.edge,this.edgeDir);
    this.pos=0.05; 
    this.speed=0; this.maxSpeed=1+Math.random()*1.2; this.wait=0; this.img=img;
    this.edge.laneCars[this.edgeDir][this.lane].push(this);
  }

  selectLane(edge,edgeDir){
    let laneCandidates = [...Array(edge.lanesPerDir).keys()]; // [0,1] forward/backward
    if(edge.type==="main") laneCandidates = [...Array(edge.lanesPerDir).keys()]; // forward/backwardåˆ¥ã«2è»Šç·š
    // ç©ºããŒå°‘ãªã„è»Šç·šã‚’å„ªå…ˆ
    let minCount = Infinity, chosen=laneCandidates[0];
    for(const ln of laneCandidates){
      const cnt = edge.laneCars[edgeDir][ln].length;
      if(cnt<minCount){ minCount=cnt; chosen=ln; }
    }
    return chosen;
  }

  update(){
    const laneArr=this.edge.laneCars[this.edgeDir][this.lane];
    const ahead=laneArr.filter(c=>c.pos>this.pos).sort((a,b)=>a.pos-b.pos)[0];
    let targetSpeed=this.maxSpeed;
    if(ahead){
      const dist=(ahead.pos-this.pos)*this.edge.length;
      if(dist<MIN_GAP){ targetSpeed=0; this.wait++; }
      else if(dist<SLOW_GAP) targetSpeed=this.maxSpeed*(dist/SLOW_GAP);
    }
    const nextNode=this.edgeDir==="forward"?this.edge.to:this.edge.from;
    if(nextNode.type==="cross" && !nextNode.external && this.pos>0.9){
      let canGo=false;
      if(this.edgeDir==="forward" && nextNode.phase===0) canGo=true;
      if(this.edgeDir==="backward" && nextNode.phase===1) canGo=true;
      if(!canGo) targetSpeed=0;
    }
    this.speed+=(targetSpeed-this.speed)*0.2;
    this.pos+=this.speed/this.edge.length;
    this.pos=Math.min(this.pos,1);

    if(this.pos>=1){
      laneArr.splice(laneArr.indexOf(this),1);
      this.edgeIndex++;
      if(this.edgeIndex>=this.route.length){
        const currentNode = this.edgeDir==="forward"?this.edge.to:this.edge.from;
        const newRoute = generateRouteBFS(currentNode);
        if(newRoute && newRoute.length>0){
          this.route = newRoute;
          this.edgeIndex=0;
        } else {
          cars.splice(cars.indexOf(this),1);
          return;
        }
      }
      const nextStep=this.route[this.edgeIndex];
      if(!nextStep || !nextStep.edge){ cars.splice(cars.indexOf(this),1); return; }
      this.edge=nextStep.edge;
      this.edgeDir=nextStep.dir;
      this.lane=this.selectLane(this.edge,this.edgeDir);
      this.pos=0.05;
      this.edge.laneCars[this.edgeDir][this.lane].push(this);
    }
  }

  draw(){
    const x0=this.edge.from.x; const y0=this.edge.from.y;
    const x1=this.edge.to.x; const y1=this.edge.to.y;
    const vx=x1-x0; const vy=y1-y0;
    const pos=this.pos; const lanes=this.edge.lanesPerDir;
    const totalWidth=lanes*2*laneWidth;
    const offset=this.edgeDir==="forward"
        ? -totalWidth/2 + laneWidth/2 + this.lane
        : totalWidth/2 - laneWidth/2 - (lanes-1-this.lane);
    const nx=-vy/Math.sqrt(vx*vx+vy*vy);
    const ny=vx/Math.sqrt(vx*vx+vy*vy);
    const cx=x0 + vx*pos + nx*offset;
    const cy=y0 + vy*pos + ny*offset;
    const angle = Math.atan2(vy, vx) + (this.edgeDir==="backward"?Math.PI:0);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    if(this.img) ctx.drawImage(this.img, -10, -6, 20, 12);
    else{ ctx.fillStyle="yellow"; ctx.fillRect(-6, -4, 12, 8); }
    ctx.restore();
  }
}

// ===== éƒ½å¸‚ç”Ÿæˆ =====
function generateCity(){
  nodes.length=0; edges.length=0;
  const mainCols=5, mainRows=4, marginX=150, marginY=100;
  const spacingX=(1000-2*marginX)/(mainCols-1);
  const spacingY=(700-2*marginY)/(mainRows-1);
  const mainNodes=[];
  for(let i=0;i<mainRows;i++){ 
    for(let j=0;j<mainCols;j++){
      const n=new Node(marginX+j*spacingX, marginY+i*spacingY,"cross",false);
      nodes.push(n); mainNodes.push(n);
    }
  }
  for(let i=0;i<mainRows;i++){
    for(let j=0;j<mainCols;j++){
      const n = mainNodes[i*mainCols+j];
      if(j<mainCols-1) addEdgeSafe(n, mainNodes[i*mainCols+(j+1)], "main");
      if(i<mainRows-1) addEdgeSafe(n, mainNodes[(i+1)*mainCols+j], "main");
    }
  }

  // æ”¯ç·šç”Ÿæˆ
  for(const n of mainNodes){
    if(Math.random()<0.4){
      const angle = Math.random()*2*Math.PI;
      const dist = 60+Math.random()*40;
      const x = n.x + Math.cos(angle)*dist;
      const y = n.y + Math.sin(angle)*dist;
      const branchNode = new Node(x,y,"cross",false);
      nodes.push(branchNode);
      if(!addEdgeSafe(n, branchNode,"branch")) edges.push(new Edge(n, branchNode,"branch"));
    }
  }

  // å»ºç‰©ç”Ÿæˆ
  for(const edge of edges){
    const numBuildings = 1 + Math.floor(Math.random()*2); 
    for(let i=0;i<numBuildings;i++){
      const t = 0.2 + Math.random()*0.6;
      const offset = (Math.random()<0.5?1:-1) * (20 + Math.random()*10);
      const vx=edge.to.x - edge.from.x;
      const vy=edge.to.y - edge.from.y;
      const length = Math.sqrt(vx*vx + vy*vy);
      const nx = -vy/length;
      const ny = vx/length;
      const x = edge.from.x + vx*t + nx*offset;
      const y = edge.from.y + vy*t + ny*offset;
      const type = Math.random()<0.8?"house":"park";
      const img = type==="house"? houseImgs[Math.floor(Math.random()*houseImgs.length)] : parkImg;
      nodes.push(new Node(x,y,type,false,img));
    }
  }

  // å¤–éƒ¨ãƒãƒ¼ãƒ‰ç”Ÿæˆ
  for(let i=0;i<6;i++){
    const x=Math.random()*1000;
    const y=Math.random()<0.5?0:700;
    const ext=new Node(x,y,"cross",true);
    nodes.push(ext);
    const mainNode=mainNodes[Math.floor(Math.random()*mainNodes.length)];
    edges.push(new Edge(ext, mainNode,"branch"));
  }
}

// ===== BFSãƒ«ãƒ¼ãƒˆç”Ÿæˆ =====
function generateRouteBFS(startNode){
  let targets = nodes.filter(n => (n.type==="house" || n.type==="park" || n.external) && n !== startNode);
  if(targets.length===0) targets = nodes.filter(n=>n.type==="cross" && n !== startNode);

  const queue = [{node:startNode, path:[]}];
  const visited = new Set([startNode]);

  while(queue.length>0){
    const {node,path} = queue.shift();
    if(targets.includes(node) && path.length>0) {
        return path;
    }
    const nextEdges = edges.filter(e=> e.from===node || e.to===node);
    for(const e of nextEdges){
      const nextNode = e.from===node ? e.to : e.from;
      if(visited.has(nextNode)) continue;
      visited.add(nextNode);
      queue.push({node: nextNode, path:[...path,{edge:e, dir:e.from===node?"forward":"backward"}]});
    }
  }
  return null;
}

// ===== è»Šç”Ÿæˆ =====
function spawnCar(){
  const entryNodes = nodes.filter(n=>n.external);
  const candidates = entryNodes.filter(n=>edges.some(e=>e.from===n||e.to===n));
  if(candidates.length===0) return;
  const startNode = candidates[Math.floor(Math.random()*candidates.length)];
  const route = generateRouteBFS(startNode);
  if(!route || route.length===0) return;
  const img = carImgs[Math.floor(Math.random()*carImgs.length)];
  const car = new Car(route,img);
  cars.push(car);
}

// ===== æ™‚é–“æ›´æ–° =====
function updateTime(){
  timeCounter++; const t=timeCounter%3600;
  let baseRate=0.02;
  if(t<800||(t>1800&&t<2600)) baseRate=0.08;
  else if(t>3000) baseRate=0.01;
  if(Math.random()<baseRate*flowRate*2) spawnCar();
  document.getElementById("timeLabel").textContent=(t<800||(t>1800&&t<2600))?"Rush":(t>3000?"Night":"Day");
}

// ===== é“è·¯æç”» =====
function drawRoad(e){
  const dx=e.to.x-e.from.x; const dy=e.to.y-e.from.y;
  const angle=Math.atan2(dy,dx); const dist=Math.sqrt(dx*dx+dy*dy);
  ctx.save(); ctx.translate(e.from.x,e.from.y); ctx.rotate(angle);
  const roadHeight=e.lanesPerDir*2*laneWidth;
  let x=0; while(x<dist){ ctx.drawImage(roadImg,x,-roadHeight/2,60,roadHeight); x+=60; }
  ctx.restore();
}

// ===== UI =====
document.getElementById("flowSlider").oninput=function(){ flowRate=parseInt(this.value)/100; document.getElementById("flowVal").textContent=this.value; };
document.getElementById("greenSlider").oninput=function(){ 
  if(selectedNode){ selectedNode.greenDuration=parseInt(this.value); document.getElementById("greenVal").textContent=selectedNode.greenDuration; }
};
canvas.onclick=(e)=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left; const my=e.clientY-rect.top;
  for(const n of nodes){ 
    if(!n.external && n.type==="cross" && Math.abs(mx-n.x)<15 && Math.abs(my-n.y)<15){ 
      selectedNode=n; 
      document.getElementById("greenSlider").value=n.greenDuration; 
      document.getElementById("greenVal").textContent=n.greenDuration; 
    } 
  } 
};

// ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
function loop(){
  ctx.clearRect(0,0,1000,700);
  updateTime();
  nodes.forEach(n=>n.update());
  edges.forEach(e=>drawRoad(e));
  let jam=0;
  cars.forEach(c=>{ c.update(); c.draw(); if(c.wait>60) jam++; });
  nodes.forEach(n=>n.draw());
  document.getElementById("jam").textContent=jam;
  requestAnimationFrame(loop);
}

// ===== ç”»åƒãƒ­ãƒ¼ãƒ‰ç¢ºèª =====
const allImgs = [roadImg, parkImg, ...carImgs, ...houseImgs];
let loadedImages = 0;
allImgs.forEach(img => img.onload = () => {
  loadedImages++;
  if(loadedImages >= allImgs.length){
    generateCity(); 
    loop(); 
    console.log("âœ… v19 å®‰å®šç‰ˆ èµ·å‹•æˆåŠŸ"); 
  }
});
setTimeout(()=>{ if(loadedImages<allImgs.length){ generateCity(); loop(); console.warn("âš ï¸ ä¸€éƒ¨ç”»åƒãƒ­ãƒ¼ãƒ‰å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é–‹å§‹"); } }, 5000);
</script>
</body>
</html>
